\part{Ejercicio 2}
\section{Enunciado}
La empresa Musimundo cuenta con una serie de sucursales repartidas por el pa'is. Recientemente ha decidido cerrar su sucursal
de Iruya y llevarse toda la mercader'ia al dep'osito central. Debido al dif'icil acceso ha dispuesto s'olo un cami'on para
llevar toda la mercader'ia. Sin embargo, es posible que no todo el material pueda ser llevado en un s'olo viaje del cami'on
d'ebido a las restricciones de carga, por lo que la parte que no entre en el cami'on ser'a vendida a valores despreciables el
 d'ia del cierre.

Dada la capacidad de carga m'axima P del cami'on y una lista de los productos del local conteniendo el valor $v_i$ y peso $p_i$ 
de cada uno, encontrar la lista de productos de mayor valor que sea posible llevar en el cami'on sin que el peso total de la
lista supere la carga m'axima. El valor de una lista de productos se calcula como la suma de los valores de los productos
involucrados. En caso de haber varias listas con el mismo valor m'aximo, encuentre cualquiera de ellas.
Realice un algoritmo para resolver el problema usando la t'ecnica de backtracking.

\section{Desarrollo}
Dado que el problema deb'ia ser resuelto con backtracking, buscamos la forma de aplicar dicha t'ecnica 
algor'itmica para su resoluci'on. B'asicamente la idea es formar todos los subconjuntos de cosas para encontrar aquel que maximice el valor total, 
sin exceder la capacidad de carga del cami'on.

La restricci'on expl'icita es el conjunto de cosas a llevar y la restricci'on impl'icita es la capacidad de carga del cami'on. A 
medida que se va armando una soluci'on, son descartadas aquellas cuyo peso excede la capacidad del cami'on, y de 
esta manera se va podando el 'arbol de posibles soluciones.

De esta manera, se construye el siguiente 'arbol de recursion:
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./ejercicio2/arbol.png}
\end{figure}
En la ra'iz del 'arbol se tiene la soluci'on $\emptyset$. Luego, en cada nodo se tiene una $n-upla$ donde un $0$ en la posici'on $i$ 
indica que el elemento $i$ no es parte de esta soluci'on, mientras que  un $1$ indica que el elemento est'a inclu'ido en la soluci'on.
Las hojas de este 'arbol son las soluciones posibles. Como cada elemento puede estar o no estar, se tienen dos posibilidades para cada
uno (llevarlo o no). Esto implica que la cantidad posible de soluciones si se tienen $n$ elementos es $2^n$.

El algoritmo implementado toma como par'ametros el camion (cosas, cuantas cosas y capacidad)  y dos soluciones posibles (una en donde est'a guardada la mejor 
encontrada hasta el momento y otra que guarda la que se va construyendo). Adem'as se lleva un 'indice que 
indica sobre que objeto se est'a decidiendo si conveniente o no llevarlo.

B'asicamente una llamada a la funci'on consiste en verificar si se agrega o no a la soluci'on el elemento apuntado por $indice$. Si es as'i (es 
decir que al agregarlo, el peso total no excede el peso m'aximo), se agrega a la soluci'on candidata y se contin'ua con la 
siguiente llamada recursiva. 'Esta consiste en una llamada sin agregar el elemento apuntado por 'indice. Cuando se encuentra 
una soluci'on mejor a la actualmente 'optima, 'esta es reemplazada. Repitiendo este proceso se pueden observar todas 
las hojas del arbol, para quedarse con la mejor.

Ademas de la restricci'on propia del problema, buscamos definir otras que nos permitieran efectuar mejores podas. Asi una primera idea fue ordenar el arreglo en orden creciente de pesos. De esta forma, si durante la construccion de una solucion, llegamos a que el elemento k no se puede agregar, sabemos que ningun elemento entre $k+1$ y n se va a poder agregar, porque su peso es mayor que el de k, y por ende mayor que la capacidad disponible.

Otra idea que tuvimos consisti'o en preguntar cuando estoy construyendo una soluci'on si tiene sentido que siga bajando. Esto lo hacemos de la siguiente manera: si considero la suma de los valores de los elementos que me quedan por visitar y este valor sumado al del candidato actual no me da mejor que el de la mejor soluc'on hasta el momento, no tiene sentido que baje porque no voy a lograr una soluci'on con valor mayor. En un principio, para hacer esto se nos ocurri'o hacer la suma en cada llamada para ver si bajo. Sin embargo este calculo era costoso, por lo cual buscamos alguna alternativa mejor. La idea entonces fue antes de empezar a trabajar con el arreglo de cosas, sumar el valor de todos los elementos. Este n'umero es el m'aximo valor que puedo lograr con un conjunto de cosas. Cada vez que hago una llamada calculo si el valor de mi candidato actual mas el m'aximo me sirve para mejorar mi solucion. Por otro lado, cuando hago una llamada sin incluir a un elemento, resto al m'aximo posible el valor de dicho elemento.

Por ejemplo:

Si tengo un conjunto de cosas tal que sus valores son: {1,2,3,4}. El m'aximo valor que podr'ia llevar es 10. Cuando estoy armando una soluci'on que excluye al valor 1, el maximo es 9. Si ademas quito al 2, el maximo es 7, etc.
Consideramos que si bien estas podas no nos mejorar'an el orden de complejidad, si nos permitirian en general observar un mejor desempe\~{n}o.

Para implementar el algoritmo se definieron los tipos $Cosa$, $Camion$ y $SolucionPosible$ con la finalidad de aportar m'as claridad al mismo.

\section{Pseudoc'odigo}
\input{ejercicio2/seudocodigo/mochila.tex}

%TODO: completar esta demostracion, hablar de tamaño de entrada. Tarea de fede
%hablar de peor caso
\section{C'alculo de complejidad}
Para este ejercicio decidimos usar el modelo uniforme, ya que consideramos que lo que hace al n'ucleo del problema es la
cantidad de cosas a llevar. Por esa raz'on no nos parece desacertado considerar que el peso y el valor de las cosas estan 
acotados. Asimismo consideraremos que el tama\~{n}o de la entrada es la cantidad de cosas entre las cuales elegir.

Antes de llamar a la funcion que hace backtracking, lo que hace el algoritmo es ordenar el arreglo con merge sort (lo cual es O(n*log(n)) y luego suma todos los valores del arreglo, lo cual es O(n). Veremos a continuacion que como el orden de la funcion principal  mayor que estos, no hacen a la complejidad del algoritmo. 

Sea N la cantidad de cosas que hay para elegir. Observemos que dado un N, si llamamos n a la cantidad de elementos que me quedan por procesar (es decir por decidir que hacer con ellos) la
T(0) = N + 1, pues hay que preguntar si encontre una mejor soluci'on y hay que copiar la soluci'on actual. Si no me quedan mas elementos que mirar y tengo que copiar la nueva solucion, esta copia tiene como costo la cantidad de elementos entre los cuales elegir.
Entonces podemos decir que las ecuaciones de recurrencia son:
$$T(0) = N +1$$
$$T(n) = 2*T(n-1) + k$$
k viene de las operaciones que se realizan dentro de cada llamda, las cuales son todas O(1).

Proponemos que: $$T(n) = N*2^n + k*(2^n-1) + 2^n$$

veamoslo por inducci'on:
n = 0:\\
$$T(0) = N + 1 =  N*2^0 + k*(2^0-1) + 2^0$$
supongamos que vale para n, veamos que vale para n+1:
$$T(n+1) = 2T(n) + k$$
usando la hipotesis inductiva:
$$T(n+1) = 2(N*2^n + k*(2^n-1) + 2^n) + k$$ 
$$T(n+1) = N*2^{n+1} + k*(2^{n+1}-2) + 2^{n+1} + k$$
$$T(n+1) = N*2^{n+1} + k*(2^{n+1}-1) + 2^{n+1}$$
Que era lo que queriamos ver.
Ahora bien como $$T(n) = N*2^n + k*(2^n-1) + 2^n$$, y ademas sabemos que n es del orden de N, tenemos que T(n) $\in$ $O(N*2^N)$

Luego el algoritmo tiene un orden exponencial en funci'on del tama\~{n}o de la entrada, a'un pese a las podas; y esto es de esperarse ya que las podas funcionan en algunos casos, mientras que en otros no ayudan en nada. 

Observando las podas que implementamos, uno esperaria que en general el algoritmo se comporte bien. Ahora supongamos que tenemos un conjunto ${a_1,a_2,...a_n}$ donde el peso y el valor de $a_i = 1$ $\forall i \in {1...n-1}$ y el peso y valor de  
$a_n = n$ y que el peso del camion es n.
En este caso ninguna de nuestras podas van a funcionar, puesto que la poda por pesos baja siempre hasta el ante ultimo nivel, salvo en el caso donde no agregue a ningun $a_i$ con i $<$ n. Tampoco funciona ver cual es el m'aximo que puedo armar porque hasta que no llegue al caso donde solo pongo a $a_n$ el valor m'aximo que puedo armar siempre es mayor que n, pero las soluciones que arme siempre valen menos que n. De esta manera en este caso, se recorren practicamente todas las ramas. 

\subsection{Experiencias realizadas}
Para probar el comportamiento del algoritmo medimos tiempos y cantidad de operaciones en funcion del tama\~{n}o de la entrada, es decir de la cantidad de posibles elementos a llevar. A modo de ver si nuestras podas significaban una mejora en la practica contrastamos los resultados entre el algoritmo sin podas, y el algoritmo con podas. Para hacer las pruebas generamos casos donde la cantidad de elementos era creciente y la composicion de las cosas era aleatoria. El peso que el camion podia llevar se fijo en 200 y los valores y pesos de las cosas seguian una distribucion uniforme (0,100). Ademas se analizo el comportamiento del algoritmo en aquellas situaciones que consideramos como peores casos. Para contar tiempo y operaciones, no se tuvo en cuenta el tiempo necesario para reordenar el arreglo, ya que sin hacer esto el problema estaba resuelto, y solo lo reordenamos por una cuestion de enunciado que nos impone devolver la soluci'on con un formato dado.
\subsection{Gr'aficos}
%TODO: sergio hace los graficos con n creciente y aleatorio

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio2/benchmark/graficos/operaciones_peor_caso/cantOperacionesPeorCaso.png}
\caption{Cantidad de operaciones en funci'on de la cantidad de cosas en peor caso}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio2/benchmark_tiempos/graficos/tiempo_peor_caso/tiempobackTracking.png}
\caption{Tiempo en funci'on de la cantidad de cosas en peor caso}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../../codigo/ejercicio2/benchmark_tiempos/graficos/tiempo_aumentando_cant_articulos/aumentandoCantArticulosPromedio.png}
\caption{Cantidad de operacione en funci'on de la cantidad de cosas (peso y valor aleatorios con distribuci'on uniforme)}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../../codigo/ejercicio2/benchmark/graficos/operaciones_prom/operacionesProm.png}
\caption{Tiempo en funci'on de la cantidad de cosas (peso y valor aleatorios con distribuci'on uniforme)}
\end{figure}

\section{Discusi'on}
En los gr'aficos podemos observar lo anteriormente demostrado. Tanto los gr'aficos de tiempo en funci'on de cosas como los de cantidad de operaciones en funci'on de cosas muestran un comportamiento exponencial para los peores casos. Para contrastar los resultados y mostrar realmente el comportamiento, encontramos funciones de tipo $f(x) = k*2^x + c$ que respetan el patr'on de crecimiento de la muestra experimental y confirma la teor'ia.
Finalmente, es intuitivo el comportamiento exponencial del algoritmo en el caso promedio (Figura 9 y Figura 10). Probablemente las irregularidades que vemos en la Figura 9 y la Figura 10 desde n = 25 a n = 32 aprox sean por causa del caso que haya sido resultante de la construccion aleatoria del mismo. A pesar de esto, independientemente del valor y del peso de las cosas, a medida que se agregan elementos al inventario, tambien se agregar'a igual cantidad de niveles al 'arbol de decisi'on. De esta forma, para 1 elemento, el arbol tendra 2 niveles (tomar o no el elemento), 2 elementos tendran 3 niveles (tomar o no el primer elemento, tomar o no el segundo). De esta forma conseguiremos con $n$ elementos, un 'arbol de $n+1$ niveles, que al agregar un elemento al inventario, se duplica la cantidad de soluciones posibles por las que probablemente el algoritmo iterar'a.
