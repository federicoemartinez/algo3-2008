\part{Ejercicio 1}
\section{Enunciado}
Dado un n'umero natural n mayor que 1, encontrar el n'umero primo $p$ que aparece con mayor potencia en la factorizaci'on 
de n. En caso de haber m'as de un n'umero primo con  la mayor potencia, encontrar el mayor de ellos.

%TODO: revisar la claridad de esto, ver si se puede mejorar
\section{Desarrollo}
La primer idea para resolver el ejercicio fue obtener los primos menores que el n'umero a factorizar
(en adelante $n$) y luego obtener la potencia con la que cada uno lo divide, qued'andonos con el de mayor
potencia o con el mayor de todos los de m'axima potencia. Sin embargo esta soluci'on era costosa, ya que
requer'ia obtener primeramente todos aquellos primos que sean menores a $n$.
\paragraph{}
Un segundo acercamiento nos permiti'o salvar esta dificultad, de manera que no fue necesario obtener 
los primos menores a $n$ expl'icitamente. El proceso consiste en partir de 2, probar manualmente si 2, 3 y 5 
dividen a $n$ y a partir  de aqu'i ciclar generando n'umeros de la forma $6*k + 1$ o $6*k + 5$ con $k \geq 1$ 
(se puede demostrar que los n'umeros primos mayores que 5 tienen esta forma (ver Demostraci'on 1)).
\paragraph{}
Cuando hallamos alg'un n'umero primo que divide a $n$, buscamos su multiplicidad dividiendo nuestro n'umero 
por dicho primo, tantas veces como sea posible. Una vez calculada, se verifica si esta nueva multiplicidad 
es mayor a la guardada hasta el momento. Si lo es, 'esta es reemplazada por la nueva. Una vez hecho esto 
se pasa al siguiente posible primo, repitiendo el proceso anterior pero ahora con un nuevo $n$ que llamaremos 
$n'$, y que resulta de dividir $n$ por el n'umero primo, elevado a la potencia hallada. Este proceso se repite 
mientras nuestro pr'oximo primo no supere la ra'iz de $n'$. Un problema de este m'etodo es que se hacen 
divisiones por n'umeros que no son primos, pero su costo es menor compar'andolo con otras metodolog'ias que
buscan todos los primos menores a $n$, o que verifican si dicho n'umero lo es antes de hacer la divisi'on.
\paragraph{}
Es importante notar que si un n'umero no es primo, este no puede dividir a $n$ (ver demostraci'on 2). Si 
no se pudiera asegurar esto, el algoritmo fallar'ia. Un ejemplo simple seria al factorizar $30 = 2*3*5$. 
En este caso se guardar'ia a 15 como m'aximo factor primo, lo cual resulta claramente err'oneo. Finalmente, 
utilizamos un teorema que nos dice que si un n'umero es compuesto existe por lo menos un primo menor que su 
ra'iz cuadrada que lo divide (ver demostraci'on 3), lo que nos permite iterar solo hasta la ra'iz del n'umero 
(la cual se actualiza luego de terminada la divisi'on) en vez de hasta $n$.

\section{Demostraciones}
\subsection{Teorema 1}
\paragraph{Enunciado:}
Sea p $\in$ $\enteros$, primo , p $>$ 5, entonces $\exists$ k $\in$ $\enteros$ $\geq$ 1  tal que p = $6*k+1$ o p = $6*k +5$.
\paragraph{Demostraci'on:}
Lo demostraremos por absurdo.\\ 
Supongamos que $\exists$ p $\in$ $\enteros$, primo, tal que p $>$ 5 y p $\not\equiv$ 1  $\mod{6}$ y p
$\not\equiv$ 5  $\mod{6}$, luego p = $6*k + j$ con j $\in$ ${0,2,3,4}$ \\
si $j = 0$\\
$6*k$ $\equiv$ 0  $\mod{6}$, absurdo pues p es primo\\
si $j = 2$\\
$6*k + 2$ $\equiv$ 0  $\mod{2}$, absurdo pues p es primo \\
si $j = 3$\\
$6*k + 3$ $\equiv$ 0  $\mod{3}$, nuevamente absurdo\\
si $j = 4$\\
$6*k + 4$ $\equiv$ 0  $\mod{2}$, tambi'en llegamos a un absurdo.\\
Ergo, si p es primo y p $>$ 5, entonces p = $6*k+1$ o p = $6*k +5$.

\subsection{Teorema 2}
\paragraph{Enunciado:}
Sea k $\in$ $\enteros$ compuesto, y sea n $\entero$ para todo p $\entero$ primo, p $<$ k, $(n:p) = 1$, entonces n $\not\equiv$ 0 $\mod{k}$
\paragraph{Demostraci'on}
Dado que k es compuesto existen $q_1,\ldots,q_j$ con $q_i$ primo tal que $q_1*\ldots*q_j = k$ \\
Supongamos que n $\equiv$ 0 $\mod{k}$,\\
Entonces como los $q_i$ son primos, vale que n $\equiv$ 0 $\mod{q_1}$ 'o ... 'o $n \equiv 0 \mod{q_j}$ \\
Pero sabemos que $q_i < k$ y que por lo tanto $(n:q_{i}) = 1$ \\
Llegamos entonces a un absurdo que provino de suponer que  $n \equiv 0 \mod{k}$ \\ 
Luego $n \not\equiv 0 \mod{k}$, que era lo que quer'iamos probar.

\subsection{Teorema 3}
\paragraph{Enunciado:}
$k$ $\entero$, $k>1$; $k$ es compuesto $\longleftrightarrow$ $\exists p$ primo tal que $p \leq \sqrt{k}$ y $k \equiv 0 \mod{p}$
\paragraph{Demostraci'on:}
Analizamos por separado las dos implicaciones: \\
$\leftarrow)$ trivial \\
$\rightarrow$) Como $k$ es compuesto se puede factorizar como $p_1*...*p_n$ con $p_i > \sqrt{k} \forall i \in {1...n}$\\
Entonces \\
$k = p_1*...*p_n > (\sqrt{k})^2*T$ , con $T>1$\\  
$k = p_1*...*p_n > \sqrt{k}^2*T$ pero $k*T > k$ \\
Absurdo, que provino de suponer que $p_i > \sqrt{k}$ $\forall i \in {1...n}$.\\

%TODO: hacer el cambio al pseudocodigo para q sea mas facil la demo
\section{Pseudoc'odigo}
\input{ejercicio1/seudocodigo/primos.tex}

%En el pseudoc'odigo presentado se utilizan dos funciones auxiliares:
En el pseudoc'odigo presentado se utiliza una funcion auxiliar:
\begin{itemize}
%\item $limite(n)$ es una macro para $\lceil\sqrt{n}\rceil$
\item $generar\_candidato()$ es un procedimiento tipo $factory$ que conserva un estado interno 
y genera candidatos a n'umeros primos como se describi'o en el Teorema 1
\end{itemize}

%TODO: hablar del calculo de complejidad, de porq logaritmico, hacer el calculo
%TODO: analisis de peor caso!
\section{C'alculo de complejidad}
\paragraph{}
En este ejercicio usamos el modelo logar'itmico de complejidad ya que la entrada del problema es 'unicamente un
n'umero entero y el grueso de las operaciones involucradas son 'unicamente sentencias de control de flujo
y operaciones aritm'eticas sobre enteros. En funci'on de esto no ser'ia l'ogico despreciar el aumento del costo
de operar sobre dichos n'umeros a medida que la entrada crece.

\paragraph{}
A partir del pseudoc'odigo se puede identificar r'apidamente el bucle principal donde se realizan la mayor'ia
de las operaciones. Veamos primero el c'odigo fuera del bucle.
\begin{itemize}
\item $limite(n)$ tiene un costo $O(log^3 n)$, puesto que la operaci'on m'as costosa que realiza es una ra'iz
cuadrada, y la complejidad de dicha operaci'on es la m'as importante. En este caso $n$ es una variable que contiene
inicialmente el valor del par'ametro de entrada y a lo largo de la ejecuci'on se divide en sucesivas ocasiones, por
lo tanto su valor decrece y est'a acotado por el valor inicial.
\item $generar\_candidato()$ tiene un costo $O(log^2 n)$ ya que para casos grandes solo efect'ua un chequeo de
una variable booleana y una multiplicaci'on de un entero acotado por $n$.
\end{itemize}
El resto de las operaciones realizadas antes y después del bucle tienen una complejidad de a lo sumo $O(log$ $n)$,
y por lo tanto son despreciables respecto del orden predominante que es hasta el momento $O(log^3 n)$ si no tenemos
en cuenta al ciclo principal.

\paragraph{}
Observemos ahora el comportamiento de dicho bucle. Se demostrará a continuaci'on que este bucle se ejecuta a lo sumo
$O(\sqrt{n})$ veces, pero por el momento veamos la complejidad del c'odigo contenido en el mismo. Si observamos
l'inea por l'inea el pseudoc'odigo puede verse que el cuerpo del ciclo es una sucesi'on de operaciones aritm'eticas,
donde aparece una llamada a la funci'on $limite(n)$. La m'as costosa de las operaciones aritm'eticas es la ra'iz
cuadrada que tiene el mismo costo que la funci'on $limite$, por lo tanto siendo que la complejidad de dicha llamada
acota a todas las otras operaciones (sumas, restas, divisiones, comparaciones y asignaciones) puede verse f'acilmente
que el costo de ejecutar cada iteraci'on del ciclo es $O(log^3 n)$ producto de la llamada a $limite(n)$.

\paragraph{}
Resta entonces demostrar que el ciclo itera a lo sumo $O(\sqrt{n})$ veces. Si analizamos la guarda del ciclo vemos
que se trata de una conjunci'on booleana. Como es suficiente que solo una de las condiciones no se cumpla para que
el ciclo termine, vamos a analizar 'unicamente la condici'on $primoActual \leq l$, y veremos que se deja de cumplir
necesariamente tras $O(\sqrt{n})$ iteraciones. Represento por $nombre_i$ el valor de la variable $nombre$ en la 
iteraci'on $i$. Probemos que:\\
\\
\centerline{$\forall n > N$, $l_{i+1} \leq l_i - 1 \vee primoActual_{i+1} \geq primoActual_i + 1$}

\paragraph{}
Esto es suficiente puesto que es f'acil ver que $primoActual$ solo crece, y $l$ solo decrece, por lo tanto si
probamos que la distancia entre ellos disminuye en al menos 1 en cada iteraci'on (y puesto que $|primoActual - l| < l$,
ya que $primoActual$ es positivo), esto redunda en que el ciclo se ejecuta $O(l)=O(\sqrt{n})$ veces. Cabe aclarar
que esto es v'alido si se prueba para $n > N$ con $N$ acotado, ya que la complejidad es una formulaci'on asint'otica
y el costo para instancias acotadas ($n \leq N$) es fijo.


\paragraph{}
Al entrar al ciclo hay dos casos posibles: o bien $primoActual$ $|$ $n$, o no lo hace. Llamemos a estas dos
posibilidades caso 1 y caso 2 respectivamente, y analicemos por separado.
%FIXME: queda demasiado espacio aca!
\begin{itemize}
\item Caso 1: $primoActual$ $|$ $n$ \\
Veamos que en este caso se cumple $\forall n > N$, $l_{i+1} \leq l_i - 1$:
\begin{center}
$$l_i = \lceil \sqrt{n_i}\rceil$$
$$n_{i+1} =  \dfrac{n_i}{primoActual_i} \leq \dfrac {n_i}{2}$$
$l_{i+1} = \lceil \sqrt{n_{i+1}} \rceil \leq \sqrt{n_{i+1}} + 1 \leq \dfrac {\sqrt{n_i}}{\sqrt{2}} + 1
  \leq \dfrac {l_i} {\sqrt{2}} + 1 \leq l_i - 1$ para $l_i > 5$
\end{center}
%FIXME: tiene sentido probar el caso 2 por induccion? es una forrada
\item Caso 2: $primoActual \nmid n$\\
En este otro caso se cumple que $\forall n > N$, $primoActual_{i+1} \geq primoActual_i + 1$. Esto se deduce
por construcci'on del procedimiento $generar\_candidatos()$ que produce una sucesi'on de la forma: \\

\centerline{2, 3, 5, 6 * 1 + 1, 6 * 1 + 5, 6 * 2 + 1, 6 * 2 + 5, 6 * 3 + 1, 6 * 3 + 5 ...} 

Si adem'as vemos que en este caso $primoActual_{i+1}$ es el t'ermino de la sucesi'on que est'a 
inmediatamente a continuaci'on de $primoActual_i$, resulta sencillamente que el postulado es verdadero.
\end{itemize}

\paragraph{}
Finalmente como en los dos casos se cumple una de las partes de la conjunci'on booleana propuesta,
resulta que 'esta es verdadera. Demostrado esto, resulta que la complejidad total del ciclo es 
$O(\sqrt{n}$ $log^3 n)$, siendo $n$ el valor del entero que el algoritmo toma como par'ametro. 
Por otra parte sabemos que el tamaño en memoria de un entero arbitrario $n$ es $t = log_2 n$, por lo tanto:\\
\\
\centerline{$2^t = n \Rightarrow \sqrt{n}$ $log^3 n = 2^n$ $t^3$}

\paragraph{}
Finalmente pudimos demostrar que $T(t) \in O(2^n $ $t^3)$.


%TODO: hablar de que sabemos q n no es tam de entrada, que dejamos los graficos porq se ve bien el o(sqrtn), ojo con esto q me parece q es O(raiz*log^3)
\section{An'alisis Experimental}
\subsection{Experiencias realizadas}
Para el an'alisis del algoritmo decidimos medir tanto operaciones como tiempo. Primero medimos dichas variables 
para los n'umeros entre 2 y 100000 para observar un patr'on de comportamiento. A partir de esta experiencia, 
decidimos realizar otras dos, donde separamos n'umeros primos en una de ellas, y en la otra tomamos las potencias 
de un n'umero primo (en particular de 7). Esto lo hicimos por considerar que el peor caso del algoritmo es 
precisamente cuando el n'umero es primo, mientras que el mejor caso es cuando el n'umero es potencia de un primo. 
Por otro lado realizamos experiencias similares pero teniendo en cuenta ya no el numero, sino la cantidad de bits 
de su representaci'on binaria, es decir teniendo en cuenta el tama\~{n}o de la entrada. Para estas experiencias 
tomamos distintos n'umeros pero medimos la cantidad de operaciones y el tiempo en funci'on de $\lfloor log_2(n) \rfloor + 1$.

\subsection{Gr'aficos}
\subsubsection{Gr'aficos en funcion de n}

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{../../codigo/ejercicio1/benchmark/graficos/todos_los_numeros/graficosTodos.png}
\caption{Cantidad de operaciones en funci'on de $n$}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio1/benchmark/graficos/primos/graficoPrimos.png}
\caption{Cantidad de operaciones en funci'on del $n$ para $n$ primo}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio1/benchmark/graficos/potencias_de_7/graficoPotenciasDe7.png}
\caption{Cantidad de operaciones en funci'on de $n$ para $n$ de la forma $7^k$}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../../codigo/ejercicio1/benchmark_de_tiempo/graficos/todos_los_numeros/todosLosNumerosPuntosTiempo.png}
\caption{Tiempo en funci'on de $n$}
\end{figure}

\subsubsection{Gr'aficos en funcion del tama\~{n}o de la entrada}
\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{../../codigo/ejercicio1/benchmark/graficos/tamanio_Entrada_T/operacionesEntrada.png}
\caption{Cantidad de operaciones en funci'on del tama\~{n}o de la entrada}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{../../codigo/ejercicio1/benchmark_de_tiempo/graficos/tamanio_Entrada_T/Tiempo_en_funcion_bits.png}
\caption{Cantidad de operaciones en funci'on del tama\~{n}o de la entrada}
\end{figure}

\section{Discusi'on}
En los gr'aficos pudimos observar lo que el an'alisis te'orico nos anunci'o.

En la figura 1, se ve claramente como existen diversos patrones de comportamiento. As'i el techo es un funci'on del tipo ra'iz 
cuadrada, mientras que debajo se encuentran otras funciones de orden logar'itmico. Esta situaci'on se ve mas claro en los 
gr'aficos donde solo est'an los n'umeros primos y las potencias de 7. En ambos casos pudimos, mediante cuadrados m'inimos, 
encontrar una funci'on que se asemeje al comportamiento de las muestras, lo cual refuerza nuestra idea de mejor y peor caso.\\
El gr'afico en funci'on del tiempo muestra un comportamiento muy similar al gr'afico de cantidad de operaciones, pero presenta 
$outliers$ que se pueden explicar por el hecho de que tomar tiempos esta sujeto a un error de medici'on producto del uso del sistema
de pruebas por parte de otros procesos.

A la hora de analizar los gr'aficos en funci'on del tama\~{n}o de la entrada esperamos ver g'raficos con forma exponencial 
y fue exactamente eso lo que obtuvimos. En el caso de cantidad de operaciones, se mantuvo lo observado en los otros gr'aficos, 
es decir que en general los primos requieren m'as operaciones que el resto de los n'umeros, mientras que las potencias de 7 
requieren muchas menos.

Finalmente la figura 6 mantiene la tendencia, y nuevamente presenta $outliers$ propios de los factores externos que intervienen 
en la medici'on de tiempos.

A modo de conclusi'on podemos afirmar que la experimentaci'on emp'irica valid'o nuestros resultados te'oricos.
