\part{Ejercicio 3}
\section{Enunciado}
Un radix tree o PATRICIA es un trie en el cual las cadenas de nodos con un solo hijo
son compactadas y transformadas en un solo nodo. Esto permite mejorar el consumo de
memoria de la estructura en el caso en que hay pocas cadenas definidas o que muchas
cadenas tengan prefijos largos en com'un.

Esta compactaci'on genera entonces las diferencias b'asicas entre los radix trees y los tries:

a) Todos los nodos internos de un radix tree tienen como m'inimo dos hijos (excepto
posiblemente la raiz).

b) Las ramas de un radix tree pueden estar etiquetadas con m'as de un caracter.
Si adem'as el conjunto (o del conjunto de claves del diccionario) es un conjunto libre
de prefijos, sucede que las cadenas (o los valores asociados a las claves) se encuentran
solamente en las hojas. Un conjunto libre de prefijos es aquel en el cual ningun elemento
es prefijo de otro.

Implementar un conjunto de cadenas basado en estas ideas que soporte las siguientes
operaciones:

a) Agregar una cadena al conjunto.

b) Consultar si una cadena pertenece al conjunto.

c) Sacar una cadena del conjunto.

d) Consultar la cantidad de cadenas del conjunto.

Donde las cadenas forman un conjunto libre de prefijos. Las tres primeras operaciones
deben tener complejidad $O( \| s\| )$ \footnote{Posteriormente a la presentación del trabajo, mediante un mail, se informo que el orden de la función agregar podia ser $O( \| s \| + t)$ donde t es el largo de la palabra a agregar} donde s es la clave m'as larga ya definida y $\| s \| $ indica la
longitud de s. La 'ultima operaci'on debe tener complejidad de orden constante.

El conjunto de caracteres sobre el que se van a definir las cadenas son las 26 letras min'uscu-
las del ingl'es.

\section{Desarrollo}
\subsection{PATRICIA}
Un Radix Tree o PATRICIA (Practical Algorithm To Retrieve Information Coded In Alphanumeric) es una estructura de datos 
basada en los Tries que suele cumplir el rol de diccionario. Sus claves son cadenas, y su significado es de tipo variado, 
d'andole uso para diferentes prop'ositos. La diferencia entre un PATRICIA y un Trie ya fue mencionada en el enunciado: 
un trie tiene un nodo por cada caracter de ua cadena, en cambio las ramas de un radix tree pueden estar etiquetadas con m'as de 
un caracter, y si adem'as el conjunto de claves es libre de prefijos, cada nodo del radix tendr'a almenos dos hijos.

\subsection{Sobre el dise\~{n}o de la estructura}
Por sus caracter'isticas, el PATRICIA presenta un amplio abanico de posibles implementaciones. Nosotros basicamente pensamos en cuatro formas:
\begin{itemize}
\item Con nodos formados por un arreglo (en este caso de 26 posiciones) que tiene ejes por elementos
\item con nodos formados por una lista de ejes 
\item con nodos que contienen una tabla de hash
\item con nodos que contienen un diccionario sobre AVLs
\end{itemize}

Un eje es una tupla de puntero a un nodo hijo y una cadena adjunta. Los nodos pueden tener un bit que indica la validez o invalidez del 
mismo y/o el dato (significado) a guardar. En el caso de este TP, no se piden datos a guardar, sino un conjunto. 

Optamos por implementar
los nodos con dos variantes de las ya nombradas: nodos formados por un arreglo de 26 posiciones con un bit de existencia y nodos 
formados por una lista con un bit de existencia. Como luego veremos, ambos dise\~{n}os de estructura cumplir'an las complejidades pedidas. 
El bit de existencia permite que podamos usar el patricia aun en casos donde el conjunto de entrada no este libre de prefijos, 
por ejemplo consideremos la figura \ref{fig:bitExistencia} en este caso si bien la forma del PATRICIA es la misma, 
mediante el bit de existencia podemos diferenciar si la palabra `emi' esta o no definida.

\begin{figure}[H]
\centering
\subfigure[La palabra emi no esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia.png} }\hspace{1in} 
\centering
\subfigure[La palabra emi si esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia1.png} }
\setcounter{subfigure}{0}
\caption{Utilización del bit de existencia}
\label{fig:bitExistencia}
\end{figure}

En cuanto al PATRICIA, se decidi'o que el mismo contendr'a nodos y no los definir'a dentro. O sea, separamos el objeto 'arbol 
PATRICIA del objeto nodo. Esto es as'i pues de este modo se implementa la modularidad que resulta de gran utilidad para 
implementar el PATRICIA para los diferentes tipos de nodo.

\subsection{Sobre el PATRICIA como 'arbol}
El enunciado presenta un invariante para el PATRICIA: 
\begin{itemize}
\item Todos los nodos internos de un radix tree tienen como m'inimo dos hijos (excepto
posiblemente la raiz).
\item Si adem'as el conjunto (o del conjunto de claves del diccionario) es un conjunto libre
de prefijos, sucede que las cadenas (o los valores asociados a las claves) se encuentran
solamente en las hojas. Un conjunto libre de prefijos es aquel en el cual ningun elemento
es prefijo de otro.
\end{itemize}
Este invariante deber'a conservarse durante todas las funciones.
PATRICIA nos sugiere un 'arbol formado de un conjunto de palabras dispersas en su estructura, como muestra el siguiente gr'afico.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/ej3/patricia.png}
\caption{Ejemplo de árbol patricia}
\end{figure}

Los nodos azules representan a las claves que pertenecen al conjunto. Este 'arbol se va formando a medida que agregamos y sacamos 
palabras del conjunto. A continuaci'on describiremos cuales fueron las pautas a seguir para armar dichas funciones.

\subsection{Agregando un elemento}
Cuando agregamos un elemento nos enfrentamos ante los siguientes casos:
\begin{itemize}
\item Se puede agregar el elemento sin tener que partir un eje

\begin{figure}[H]
\centering
\subfigure[PATRICIA original]{
\includegraphics[scale=0.4]{./figuras/ej3/patricia.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow.png} }
\centering
\subfigure[Bajamos lo m'aximo posible]{
\includegraphics[scale=0.4]{./figuras/ej3/patriciaCaravanaBajando.png} }
\centering
\subfigure[Patricia luego de agregar caravana]{
\includegraphics[scale=0.4]{./figuras/ej3/patriciaCaravana.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:noPartirNodo}
\end{figure}

\item Para agregar un elemento, hay que partir un eje y agregar un nodo

\begin{figure}[H]
\centering
\subfigure[PATRICIA original]{
\includegraphics[scale=0.4]{./figuras/ej3/patricia.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow2.png} }
\centering
\subfigure[Tenemos que partir el nodo de llana]{
\includegraphics[scale=0.4]{./figuras/ej3/partiendoNodo.png} }
\subfigure[Ahora que lo partimos podemos agregar la palabra como en el caso anterior]{
\includegraphics[scale=0.4]{./figuras/ej3/NodoPartido.png} }
\subfigure[Patricia luego de agregar avellaneda]{
\includegraphics[scale=0.4]{./figuras/ej3/patriciaAvellaneda.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:partirNodo}
\end{figure}

\end{itemize}

Para solucionar estos casos comenzaremos situ'andonos sobre la ra'iz. Luego bajamos por las ramas de la siguiente manera: en cada 
paso mantenemos guardada la palabra formada a partir de la concatenación de las cadenas adjuntas de los ejes por los cuales baj'e, 
y la cadena recortada que resulta de quitarle a la palabra el prefijo en com'un que tiene con cada eje por el cual baj'e. 

De esta forma en cada paso buscamos el eje tal que la primer letra de su cadena adjunta coincida con la primer letra de palabra 
recortada. As'i bajaremos por los ejes hasta que encontremos un eje que no sea prefijo, en su totalidad, de la cadena recortada, 
como se muestran los dos casos en las figuras \ref{fig:noPartirNodo}c y \ref{fig:partirNodo}c. Este algoritmo no presenta 
ambiguedades a la hora de buscar el eje por el cual bajar, pues cada nodo tiene un m'aximo de 26 hijos, correspondientes a las 26 
letras del abecedario ingl'es, y no puede tener mas de un eje que su cadena adjunta comience con la misma letra. O sea, no puede 
haber nodos con, por ejemplo, ejes con cadenas casa y cosa.

Una vez que bajamos por las ramas lo m'aximo posible, si la palabra formada es prefijo de la palabra a agregar, quiere decir que 
caimos en el primer caso. Este caso es simple y solo resta agregar el nodo y el eje correspondiente, con la palabra sin prefijo, 
como se muestra en la figura \ref{fig:noPartirNodo}, gr'afico d.

%TODO: esto es un quilombo
Si la palabra formada no es prefijo de la clave a 
definir, este es el segundo caso, pues esto querr'a decir que el 'ultimo eje tiene letras que son parte de la clave y otras que 
no lo son. Entonces haremos lo siguiente: partimos el 'ultimo eje (ver figura \ref{fig:partirNodo}, gr'afico c) y crearemos un 
nuevo padre para el nodo en el cual quedamos, de manera que la primera parte del 'ultimo eje (la que tiene letras en com'un con 
la clave) quedar'a adjunta a un eje que apunte desde el padre anterior hacia el nuevo padre, y la cadena restante del eje partido 
quedar'a adjunta al eje que le apunta desde el nuevo padre (ver figura \ref{fig:partirNodo},gr'afico d). Finalmente, para 
reestablecer el invariante, agregamos un nuevo nodo y un nuevo eje, apuntando del nuevo padre al nuevo nodo hijo, que tenga 
adjunto la parte restante de la clave (ver figura \ref{fig:partirNodo}, gr'afico e).

Excediendo el l'imite del enunciado, nuestro algoritmo agregar podr'a tener en cuenta conjuntos de entrada que no sean libre de 
prefijos. Esto nos agregar'a dos casos m'as: 
\begin{itemize}
\item Para agregar un elemento hay que simplemente setear el bit de existe

\begin{figure}[H]
\centering
\subfigure[La palabra emi no esta definida]{
\includegraphics[scale=0.4]{./figuras/ej3/bitDeExistencia.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow3.png} }
\centering
\subfigure[La palabra emi si esta definida]{
\includegraphics[scale=0.4]{./figuras/ej3/bitDeExistencia1.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:seteaExiste}
\end{figure}

\item Para agregar un elemento hay que partir un eje y setear el bit de existe
\end{itemize}
\begin{figure}[H]
\centering
\subfigure[Bajando por el 'arbol original para agregar cosa]{
\includegraphics[scale=0.4]{./figuras/ej3/BajandoPartirYExiste.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow4.png} }
\centering
\subfigure[Parto el eje y seteo bit de existe]{
\includegraphics[scale=0.4]{./figuras/ej3/PartoUnEjeYSeteoExiste.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:parteYSeteaExiste}
\end{figure}

Estos dos nuevos casos en realidad podemos resolverlos como derivados de los dos anteriores. Si al bajar por las ramas, la 
palabra formada es prefijo de la clave, y la clave es prefijo de la palabra formada, caemos en el primer caso. En este caso 
simplemente se setea el bit de existe al nodo en el cual caimos, como lo muestra la figura \ref{fig:seteaExiste}.

Si al bajar por las ramas, la clave es prefijo de la palabra formada y la palabra formada es m'as larga que la clave, caemos en el 
segundo caso. Este problema se resuelve partiendo el eje y creando un nuevo nodo en medio del eje a partir. Ahora la primer parte
 del eje partido apuntar'a al nuevo nodo, y la parte restante apuntar'a desde el nuevo nodo hacia el nodo en el cual caimos al bajar, como lo muestra la figura \ref{fig:parteYSeteaExiste}.
Claramente los dos primeros casos correspondientes al enunciado son excluyentes con estos dos 'ultimos casos, pues los primeros agregan solo nodos hojas, los segundos agregan solo nodos internos. Esto me asegura que el producto pedido no ser'a cambiado.

\subsection{Eliminando un elemento}
Cuando eliminamos un elemento nos enfrentamos ante los siguientes casos:
%FIXME: cuales son los casos, solo hay figuras
\begin{figure}[H]
\centering
\subfigure[PATRICIA]{
\includegraphics[scale=0.4]{./figuras/ej3/SeBorraLaHojaYNoSeMergea1.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow5.png} }
\centering
\subfigure[Bajamos lo m'aximo posible]{
\includegraphics[scale=0.4]{./figuras/ej3/SeBorraLaHojaYNoSeMergea2.png} }
\centering
\subfigure[Patricia luego de sacar dama]{
\includegraphics[scale=0.4]{./figuras/ej3/SeBorraLaHojaYNoSeMergea3.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:borroYNoMergea}
\end{figure}

\begin{figure}[H]
\centering
\subfigure[PATRICIA original]{
\includegraphics[scale=0.4]{./figuras/ej3/patricia.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow6.png} }
\centering
\subfigure[Bajamos lo m'aximo posible]{
\includegraphics[scale=0.4]{./figuras/ej3/BorroHojaYMergeo1.png} }
\centering
\subfigure[Patricia luego de sacar dato]{
\includegraphics[scale=0.4]{./figuras/ej3/BorroHojaYMergeo2.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:borroYMergea}
\end{figure}
Para solucionar estos casos comenzamos situ'andonos sobre la ra'iz, y bajando, al igual que agregar. En estos casos, hay que eliminar una hoja, como lo muestra el siguiente gr'afico:

%FIXME: hacer este grafico 
[Grafico bajando por rama para sacar(dama)] 8

Al borrar la hoja, debemos verificar cuantos hermanos ten'ia. Si ten'ia m'as de un hermano, caeremos en el primer caso, 
el cual se resuelve simplemente eliminando la hoja y su eje, como lo muestra el gr'afico \ref{fig:borroYNoMergea}. Si, por el contrario, ten'ia solo 
un hermano, al borrar este nodo al padre le restar'a un solo hijo, como lo muestra la figura. Para reestablecer el invariante, 
como la rama hasta el nodo padre no conforma una clave definida, podemos unir el padre con su 'unico hijo. Lo hacemos simplemente
 borrando el nodo hijo y concatenando el eje que apunta del nodo abuelo al nodo padre con el eje que apunte del nodo padre al
 nodo hijo, como lo muestra el grafico \ref{fig:borroYMergea}.

Excediendo el l'imite del enunciado, nuestro algoritmo sacar podr'a tener en cuenta conjuntos de entrada que no sean libre de 
prefijos. Esto nos agregar'a dos casos m'as: 
\begin{itemize}
\item Para sacar un elemento hay que setear FALSE el bit de existe
\begin{figure}[H]
\centering
\subfigure[La palabra emi esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia1.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow7.png} }\hspace{1in} 
\centering
\subfigure[La palabra emi no esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:casoExtraSacarA}
\end{figure}

\item Para sacar un elemento hay que concatenar dos ejes y borrar un nodo

\begin{figure}[H]
\centering
\subfigure[La palabra emi esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/casoExtraSacar1.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow8.png} }\hspace{1in} 
\centering
\subfigure[PATRICIA luego de eliminar emi]{
\includegraphics[scale=0.5]{./figuras/ej3/casoExtraSacar2.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:casoExtraSacarB}
\end{figure}

\end{itemize}
Estos dos nuevos casos son consecuencia directa de los casos de entrada que no esta libre de prefijos de agregar. 
Luego de bajar por las ramas del 'arbol verificamos que la palabra armada es igual a la clave y el nodo existe. De esta forma nos
 aseguramos que la clave a borrar haya sido definida. Si el nodo a borrar es un nodo interno (no es una hoja), caemos en alguno
 de estos dos casos. Si el nodo a borrar tiene mas de un hijo, caemos en el primer caso. Este se soluciona seteando el bit de 
 existencia del nodo a falso, como muestra la figura \ref{fig:casoExtraSacarA}. Si el nodo a borrar tiene solo un hijo, este es
 el segundo caso. Se resuelve borrando el nodo padre y concatenando el eje que apuntaba del nodo padre al nodo actual, y el eje
 del nodo actual al nodo siguiente, como lo muestra la figura \ref{fig:casoExtraSacarB}.
 
Claramente estos dos casos son excluyentes con los dos primeros correspondientes al enunciado, pues en ellos se borran solo hojas, mientras que estos ultimos se borran nodos internos.

\subsection{Pertenencia de una cadena al conjunto}
La idea es bajar por los ejes que son prefijos de s, hasta que o bien completamos s o bien no tenemos ejes que sean prefijo de s. Si completamos s, revisamos que el nodo exista  y si esa asi se devuelve verdadero; en otro caso devolvemos false.

\subsection{Cardinal}
Dado que se nos pedia devolver el cardinal en orden constante, no nos quedo otra alternativa que tenerlo calculado cuando se llame a la función. Por eso, tenemos el valor calculado, incrementándolo y decrementándolo cuando se agrega o saca una palabra, respectivamente.


\section{Cuestiones de implementacion de los nodos y del PATRICIA}
Con respecto a las listas (para los nodos que las usan) usamos las porvistas por la Standard Template Library (STL). Un nodo guarda la cantidad de hijos que tiene y si el existe. Si bien aislando el nodo como estructura independiente, el booleano `` existe' puede carecer de sentido, lo adquiere al implementar el PATRICIA, ya que sin ella no podriamos diferenciar los elementos definidos de los no definidos. La cantidad de hijos es util para saber cuantos hijos contiene un nodo implementado sobre arreglos.

La implementaci'on de nodos sobre arreglos cuenta con un arreglo de apuntadores a eje, analogamente la implementaciópn con listas cuenta con una lista con apuntadores a ejes. Un eje, es una cadena asociada y un puntero a otro nodos

Cada nodo es capaz de agregar nodos hijos mediante un eje con una cadena adjunta, siempre y cuando no tenga hijos cuya cadena asociada a su eje comience con la misma letra. El nodo hijo lo puede crear o recibirlo como un parametro.
Asimismo, un nodo es capaz de sacar un eje que lo une a alguno de sus hijos, sin embargo no borra a dicho hijo, esto será tarea del trie. Tambien saben que palabra tiene asociada cada uno de sus hijos, lo cual sirve para poder realizar la bajada por el PATRICIA.

%TODO: creo q alcanza con lo q dije antes

%A continuaci'on explicaremos detalladamente cada funci'on referente a los nodos:
%\begin{itemize}
%\item constructor: inicializa el booleano existe a FALSE. En caso de nodo sobre arreglo, inicializa adem'as cantElem a 0 (cero) y todo el arreglo a NULL.
%\item agregar: toma por par'ametro una referencia constante a cadena y un opcional apuntador a nodo. Adhiere un nuevo nodo al conjunto de hijos del nodo en cuesti'on. Lo hace asign'andole un eje que tiene un puntero al nuevo nodo y una cadena adjunta. Si el nodo es pasado por par'ametro, el eje apuntar'a hacia ese nodo. Caso contrario se crear'a un nuevo nodo sin nodos hijos, con el bit existe en TRUE, y el eje apuntar'a hacia el nuevo nodo. Esto es as'i a causa de efectos pr'acticos a la hora de implementar el PATRICIA. Para el caso de los nodos sobre arreglos, a la i-esima letra del abecedario ingl'es le corresponde la i-esima posici'on del arreglo. En caso de los nodos sobre listas, los ejes son agregados en orden ascendiente por cadena.
%
%\item sacar: toma por par'ametro una referencia constante a cadena. Borra el eje adjunto a la cadena pasada por par'ametro. No borrar'a el nodo apuntado por el eje borrado. Esto, en cambio, ser'a tarea del PATRICIA. Para el caso de los nodos sobre arreglos, borrar el eje es trivial si indexamos el arreglo  sobre la primer letra del par'ametro. En cambio, para los nodos sobre listas, se deber'a iterar sobre la lista hasta encontrar el eje a borrar.
%
%\item pertenece: toma por par'ametro una referencia constante a cadena. Verifica si existe un eje adjunto a la cadena pasada por par'ametro. Para los nodos sobre arreglos, indexamos el arreglo sobre la primer letra del par'ametro y verificamos la igualdad. Para los nodos sobre listas, iteramos sobre la lista hasta encontrar la cadena buscada. Para ambos casos, si no se encuentra un eje adjunto a la cadena, se devuelve NULL.
%
%\item ejeQueEmpiezaCon(cadena): toma por par'ametro una referencia constante a cadena. Requiere que la cadena sea de longitud 1 (uno). Caso contrario devolver'a NULL. Devuelve un puntero a eje que tiene por primer letra el parametro. Para nodo sobre arreglos, simplemente se indexa sobre la letra del par'ametro. Para nodo sobre listas, se itera sobre la lista de ejes, hasta encontrar una coincidencia entre la primer letra de la cadena adjunta al eje iterado con el par'ametro. Si no existe tal eje, se devuelve NULL.
%
%\item iesimoEje(entero): toma por par'ametro un entero sin signo $n$. Devuelve un apuntador a eje. Para nodo sobre arreglos, se indexa el arreglo sobre el entero pasado par'ametro. Para nodo sobre listas, se itera sobre la lista de ejes, hasta iterar $n$ veces. Si no existe tal eje, se devuelve NULL.
%
%\item primerEje: no toma par'ametros. Devuelve un apuntador al primer eje encontrado. Para nodo sobre arreglos, se busca de 0 a 26 un eje definido. Para nodo sobre listas, se devuelve el primer elemento de la lista.
%
%\item cantHijos: no toma par'ametros. Devuelve el cardinal del nodo, entendi'endose por cardinal la cantidad de hijos que tiene. En realidad esta funci'on no hace mas que devolver el valor de la variable cantElem.
%
%\item esHoja: no toma par'ametros. Devuelve TRUE o FALSE indicando si el nodo no tiene ningun nodo hijo o tiene alguno, respectivamente. Simplemente se compara cantElem con 0.
%
%\item destructor: para nodo sobre arreglo, recorre el arreglo eliminando eje por eje (NO borra los nodos hijo). En caso de nodo sobre lista, no hace absolutamente nada.
%\end{itemize}

Definimos la clase PATRICIA que es `` amiga '' de la clase nodo y adem'as lo contiene. Necesita ser amigo para tener acceso a la creaci'on de ejes y uso de los metodos privados.

Un PATRICIA tiene ademas la cantidad de palabras definidas, la cual necesitamos para poder cumplir con el orden pedido para la función cardinal.

Un PATRICIA esta compuesto entonces por un nodo llamado raiz y por la cantidad de palabras que lo componen.

%TODO: y si mejor nos hacemos los pelotudos?
Para el manejo de las cadenas, usamos string de ls stl. Para las mismas necesitamos que la concatenación de una cadena s a una cadena t sea O(s), que comparar dos cadenas s y t se pueda hacer en O(min($long_s$,$long_t$)). Si bien no pudimos encontrar los ordenes en los que la stl provee estas operaciones, son ordenes faciles de cumplir, por lo que podemos suponer que valen.

%\begin{itemize}
%\item constructor: inicializa cantElem a 0 (cero) y la raiz, sete'andole TRUE a su valor existe.
%
%\item destructor: hace un recorrido postorder sobre el 'arbol: primero recorre la lista de hijos, llamando recursivamente, y luego borra el nodo actual.
%
%\item agregar: toma por par'ametro una referencia constante a cadena. Se baja por las ramas con el m'etodo bajar. Se verifica si la palabra armada es igual a la cadena y si el nodo existe. Si esto se cumple, terminar'a, pues quiere decir que la palabra ya estaba definida, sino sigue su ejecuci'on. A partir de este paso, sabemos que hay un elemento que ser'a agregado, pues es un elemento no existente en el conjunto. Luego se toma la cadena pasada por par'ametro y la palabra armada, y se les quita el prefijo. Esto lo hacemos pues as'i podemos ver si debemos partir el eje o no, ya que si la palabra armada, que es la concatenaci'on de todos los ejes por los que baj'e, no es prefijo de la cadena, quiere decir que el 'ultimo eje no coincid'ia totalmente con la parte de la cadena sin prefijo. Verificamos entonces si la palabra armada es vac'ia luego de sacarle el prefijo, si no lo es, partimos el eje y creamos un nuevo padre para este nodo. Si era vacia, no hacemos nada. Luego dependiendo si se partio el eje o no, colgamos el nuevo nodo del nuevo padre o del nodo en el que quedamos luego de bajar, y a ese eje le adjuntamos la parte sin prefijo de la cadena, con el m'etodo agregar de nodo. Finalmente se incrementa la variable cantElem, sin importar en qu'e caso entr'o, pues antes hab'iamos comprobado si la cadena a agregar no est'a definida en el conjunto.
%
%\item sacar: toma por par'ametro una referencia constante a cadena. Se baja por las ramas con el m'etodo bajar. Se verifica si se logr'o encontrar la cadena comparandola en relaci'on de igualdad con la palabra armada, y si el nodo existe. Si esto se cumple, el algoritmo sigue su ejecuci'on, sino termina. Nuevamente decimos que a partir de este paso, sabemos que hay un elemento que ser'a eliminado. Para este m'etodo resulta necesario el retorno de bajar, el eje anterior al eje actual (el que va del abuelo al padre del nodo actual), pues este nos permite resolver casos de uni'on de ejes cuando el padre del actual tiene dos hijos o menos. Empezamos por resolver los casos que el enunciado nos da: aquellos que borramos una hoja. Si el actual es hoja, lo borramos, junto con su eje, y verificamos lo siguiente: si exist'ia un nodo anterior (no se est'a borrando ning'un elemento que esta colgado de la raiz) y el anterior no existe y, luego de borrar la hoja, tiene 1 hijo, entonces tenemos que unir los ejes anterior y el eje que va del padre al 'unico hermano del nodo borrado. Los casos restantes son aquellos que se debe borrar un nodo interno. Estos se contemplan entre todo el conjunto de casos que son disjuntos con el anterior (aquellos en los que se borran hojas). Se comienza preguntando si el nodo actual tiene un unico hijo, pues debemos evitar podar toda una rama del 'arbol incorrectamente. En este caso, se concatenan los ejes del padre del actual al actual, y del actual al hijo del actual. Luego se procede a borrar el actual. Si el actual tenia m'as de un hijo, se setea el bit existe a FALSE. Finalmente se decrementa la variable cantElem en uno. Es importante notar que la variable decrementa sin importar en qu'e caso entr'o, pues antes hab'iamos comprobado si la cadena a borrar est'a definida en el conjunto.
%
%\item pertenece: toma por par'ametro una referencia constante a cadena. Devuelve un booleano. Se procede bajando por el 'arbol con el m'etodo bajar, y se verifica si se logr'o encontrar la cadena comparandola en relaci'on de igualdad con la palabra armada, y si actual existe.
%
%\item cardinal: no toma par'ametros. Devuelve un entero positivo. Esta funci'on devuelve el valor de cantElem.
%
%\item bajar: toma por par'ametro una referencia a puntero a nodo, una referencia a puntero a eje, una referencia constante de cadena, y una referencia a cadena. Devuelve un puntero a eje. El primer par'ametro corresponde al nodo actual, y funciona como variable para devolver resultados. Al algoritmo no le interesa lo que le manden en esa variable, pues al entrar define actual como raiz. An'alogamente, el segundo par'ametro funciona tambi'en como variable de retorno del eje actual (el que apunta al nodo actual) y el algoritmo asigna su valor al entrar a la funci'on. El tercer par'ametro es la cadena que se le pasa por par'ametro a agregar y a bajar. El cuarto par'ametro es la palabra armada, que es la concatenacion de todas las cadenas adjuntas a los ejes por los cuales bajaremos. A este par'ametro tambi'en se le asigna un valor, que es la cadena vac'ia, apenas se llama la funci'on. Este m'etodo tiene como fin ser reciclable: puede ser usado para bajar por el 'arbol, sin importar el caso para el cual se lo quiere usar, sea agregar, sacar o verificar pertenencia.
%Bajar define cuatro variables auxiliares: puedeBajar (bool), recortada (string), aux (puntero a eje) y ejeAnterior (puntero a eje). La primera define si el algoritmo puede seguir bajando o no por las ramas del 'arbol, la segunda sirve para guardar la parte que falta por recorrer del tercer argumento, la tercera sirve para mirar a los ejes antes de bajar, y la cuarta guarda el valor de ejeActual (segundo par'ametro) antes de ser cambiado. El m'etodo comienza llamando a actual.ejeQueEmpiezaCon d'andole la primer letra de recortada (que al principio coincide con la primer letra del tercer par'ametro). Si existe tal eje, se asigna TRUE a puedeBajar. Sino, el algoritmo finaliza. Si es cierto que se puede bajar, se procede a hacerlo actualizando los valores de eje anterior, eje actual, nodo actual, la palabra armada, la palabra recortada y puedoBajar. A puedoBajar se le asigna TRUE si el eje actual es prefijo (completo) de recortada. Sino se le asigna falso. Este procedimiento se ejecuta hasta que puedoBajar sea falso, sea porque lleg'o a una hoja o porque el eje que contiene eje actual no es totalmente prefijo de recortada.
%
%\item quitarPrefijoEnComun: toma por par'ametro una referencia a cadena y una referencia constante a cadena. Recorre letra por letra de los par'ametros, hasta que alguno de los dos llegue al final, y guarda un contador de cu'antas letras recorri'o. Al finalizar, le borra al primer par'ametro desde el principio de la cadena hasta contador. La funci'on devuelve TRUE si la longitud del segundo par'ametro es igual al valor de contador, o sea devuelve true si el segundo par'ametro es prefijo del primero. Caso contrario, devuelve FALSE.
%\end{itemize}

\section{Pseudoc'odigo}
\input{pseudo3}
\input{pseudo3b}

%TODO: que alguien me revise, por el amor de Dios!!!!!!!!!!!!!!!!!
\section{Cálculo de complejidad}
Para realizar el analisis de la complejidad vamos a considerar el modelo uniforme ya que las principales operaciones se realizan a nivel de caracteres, por lo cual podemos considerar que tienen un costo acotado. Ahora bien, con respecto al tamaño de la entrada, en este caso consideramos que es la cantidad de caracteres que componen a la cadena sobre la que se va a operar, ya sea para agregarla, borrarla o saber si esta definida. Llamos s a la cadena de entrada, y $long_s$ a el largo (cantidad de caracteres) de la misma y $long_{max}$ a la longitud de la cadena mas larga ya agregada.

A continuación analizaremos las cuatro funciones que debíamos implementar, para determinar el orden de complejidad logrado en cada una.
\subsection{Bajar}
Primero inicializamos algunas variables que son punteros. Incializamos también eje, para hacerlo, buscamos el eje que sale del nodo y comienza con la misma letra que s. En los arreglos lo hacemos en O(1).
 
Por otro lado, con las listas ocurre lo mismo, ya que a lo sumo hay 26 caracteres, es decir 26 ejes de salida para el nodo. Por lo tanto, como es una cantidad acotada por una constante, recorrer esa lista también es O(1). 

Luego viene un ciclo (l'inea 7), que itera mientras el eje exista y pueda bajar. Poder bajar, salvo en la primer iteración en la cual tiene el mismo significado que existe el eje; significa que el eje entero sea prefijo de s. Ambas condiciones se pueden dar como maximo $long_{max}$ veces, ya que no puede haber mas ejes con prefijo en s que la cantidad de ejes para guardar a la palabra mas larga, que tiene dicha longitud.

Dentro del ciclo, lo que hacemos es asignar ciertos punteros en O(1), buscar el eje por donde seguir, también en O(1), concatenar a la cadenaActual la cadena del eje que acabamos de pasar y sacar de s el prefijo del eje. Hay que notar que si en una iteracion concatenamos a palabraArmada una cadena de largo k, el maximo numero de ejes es $long_{max}$ - k, ya que como mucho podemos tener $long_{max}$ ejes de un caracter.

Entonces si el ciclo hace n iteraciones, y tenemos que en la cantidad de caracteres del iesimo eje que visitamos es $k_i$, vale que:
$$\sum_{i=1}^{n}{k_i} \leq long_{max}$$

Es por esta raz´n que la complejidad del algoritmo es O($long_{max}$).
  
\subsection{Agregar}
Lo primero que hacemos es bajar por las ramas mientras entonctremos prefijo para s, como vimos en el apartado anterior, el costo de esto es O($long_{max}$).


Si la palabra ya estaba en el conjunto(línea 5), no hacemos nada y terminamos. El costo fue en total $O(long_{max})$.

Si en cambio la palabra no estaba, lo proximo que hacemos es eliminar los prefijos comunes entre s y la palabra armada durante el descenso (línea 8) , nuevamente para hacer esto, recorremos a lo sumo $long_{max}$ caracteres, ya que lal cadenas de los ejes de una rama no pueden tener mas caracteres que $long_{max}$.

Si hay que partir el nodo, lo que se hace es partir la cadena del ultimo eje visitado en la parte que es igual a s y la parte que difiere (línea 12). Para partir esta cadena, se recorren tantos caracteres como prefijo de s halla en el PATRICIA, y esta cantidad esta acotada por $long_{max}$ caracteres.

Una vez que partimos esta cadena creamos un eje nuevo, que se hace en O($long_{max}$), porque si armamos un eje nuevo hay que copiar la parte de la cadena del eje, que no era prefijo en s(línea 14). Tambien creamos un nuevo nodo, que se hace en O(1).

Luego de esto, linkeamos los nodos mediante el eje antes creado. Y seteamos el valor de existencia del nodo. Estas acciones se hacen en O(1), lo primero es setear un puntero y lo segundo es asignar un bool.

Despu'es de esto, si hay que agregar un nuevo eje para s, se hace, pero esta vez el costo es O($long_s$), puesto que s podria ser en principio mayor que la palabra de longitud maxima entre las definidas(línea 25). Se crea un nuevo nodo y se linkea con el nodo hasta donde habia bajado en O(1).

Si no habia que partir nodo, ni agregar un nodo nuevo, solo se setea el bit de existe en el ultimo nodo que visite (línea 28) .

Por ultimo si la palabra no estaba ya en el conjunto, incrementamos en uno el cardinal del conjunto

Luego tenemos una cantidad acotada de operaciones de costo O($long_s$) y O($long_{max}$). Por lo tanto la complejidad del algoritmo es O($long_s$+$long_{max}$), es decir O(max($long_s$+$long_{max}$))

\subsection{Sacar}

Primero bajamos mientras en los ejes encontremos prefijo de s. Esto se hace en $O(long_{max})$. Notemos que como para poder sacar una palabra, pedimos como precondición que s halla sido agregada, sabemos que $long_s$ $\leq$ $long_{max}$. Entonces en verdad esta bajada tiene costo $O(long_s)$.
 
Si el nodo a borrar es una hoja, eliminamos el nodo y al eje correspondiente(línea 5). Borrar el eje, tiene $O(long_s)$ porque dicho eje, era subcadena de s.  

Una vez hecho esto, podria ser necesario, si el padre tiene ahora solo un hijo, combinar el string del eje que llega al padre con el de su hijo. Esto se hace en O($long_{max}$) ya que no sabemos a priori que tan largo puede ser la cadena del eje del ``hermano'' de s (líneas 8 a 11).

Si no era una hoja y tiene solo un hijo lo que hacemos es borrar el nodo, y combinar los ejes de él con su padre y de él con su unico hijo. Nuevamente el costo de esto es O($long_{max}$) (líneas 16 y 17).

Si no era hoja y no tenia solo un hijo, lo que hacemos es setear su flag de existe en false, que se hace en O(1). 

Lo ultimo que hacemos es decrementar en uno el cardinal del conjunto en O(1).

Luego el orden de esta operacion es  O($long_s$+$long_{max}$), pero como $long_s \leq long_{max}$, O($long_s$+$long_{max}$) es O(max($long_s$+$long_{max}$)), que es O($long_{max}$)

\subsection{Pertenece}
Al igual que con las dos operaciones anteriores, lo que hacemos es bajar mientras encontremos en los ejes, prefijos de s. Esto, como dijimos anteriormente tiene costo $O(long_{max})$. Una vez que bajamos, comparamos la cadena obtenida durante la bajada, con s. La comparación se realiza en $O(min(long_{max},long_s)) \subset O(long_{max})$
Por otro lado se pregunta si el nodo existe, pero esta operacion la realizamos en O(1).

En conclusion,el algoritmo tiene complejidad O($long_{max}$)

\subsection{Cantidad de elementos}
Como cada vez que guardamos o sacamos una palabra actualizamos el cardinal del conjunto, en caso de que se solicite la cantidad de palabras del conjunto, se devuelve este contador, sin tener que hacer mas operaciones, por lo tanto la operacion es O(1).

\section{Analisis experimental}
\subsection{Experiencias realizadas}
Para este ejercicio decidimos no solo realizar un analisis para contrastar con el analisis teorico de los algortimos, sino también comparar las dos implementaciones del PATRICIA.

Primero, lo que hicimos fue contar operaciones al agregar, buscar y borrar elementos en ambas implementaciones del PATRICIA para contrastar los resultados con el calculo de complejidad anterior. Para esto generamos conjuntos de palabras y las agregamos en orden creciente con respecto a la cantidad de caracteres. Luego las buscamos, y finalmente las borramos. 

Ademas medimos los tiempos para agregar conjuntos de palabras en cada una de ellas, de esta forma buscamos comparar cual de las dos implementaciones era mas veloz.

Finalmente consideramos que otro factor que debia ser tenido en cuenta era el espacio que ocupaban ambas estructuras, por esa razon decidimos medir la memoria que consumia cada uno al agregar varios conjuntos de palabras. Uno espera que con respecto al tiempo se comporte mejor el trie sobre arreglos, sin embargo también es de esperarse que ocupe mucha mas memoria que las listas, por esa razon nos parecion interesante ver cuanta era esta diferencia.

\subsection{Resultados}

\subsubsection{Experiencia 1: Cantidad de operaciones al agregar palabras de largo creciente en ambas implementaciones}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej3/operacionesAgregar.png} 
\label{fig:ej3exp1}
\end{figure}
Los puntos rojos, corresponden a la implementaci'on con listas, los azules con arreglos.

\subsubsection{Experiencia 2: Cantidad de operaciones al buscar palabras de largo creciente en ambas implementaciones}
\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{./figuras/graficos/ej3/operacionesPertenece.png} 
\label{fig:ej3exp2}
\end{figure}

\subsubsection{Experiencia 3: Cantidad de operaciones al quitar palabras de largo creciente en ambas implementaciones}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej3/operacionesSacar.png} 
\label{fig:ej3exp3}
\end{figure}

\subsubsection{Experiencia 4: Tiempo requerido para agregar diferentes conjuntos de palabras}
\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{./figuras/graficos/ej3/comparacionArreglosListas.png} 
\label{fig:ej3exp4}
\end{figure}

\subsubsection{Experiencia 5: Cantidad de memoria utilizada para agregar diferentes conjuntos de palabras}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej3/memoria.png} 
\label{fig:ej3exp5}
\end{figure}

\subsection{Discusión}
En las experiencias 1, 2 y 3 observamos como la cantidad de operaciones es considerablemente mayor en la implementación con listas, esto es de esperarse ya que encontrar el eje por el cual bajar es mucho mas rapido en los arreglos, si bien en ambos es O(1), las listas presentan una constante mucho mas alta, ya que si un nodo tiene 26 hijos la busqueda es lineal y se recorren en peor caso los 26 ejes.

Independientemente de la implementación se noto como la cantidad de operaciones se incrementa linealmente a medida que se agregan palabras mas largas, esto es de esperarse ya que la complejidad nos dio O($long_{max}$).

La experiencia 4 vuelve a poner de minifiesto lo que observamos anteriormente, es decir que la implementación con arreglos es mas veloz que la implementación con listas.

Finalmente la experiencia 5 nos muestra como la implementación con arreglos, que se mostro claramente mas rapida, consume una gran cantidad de memoria mas que la implementación con listas. Esta es una buena razón por la cual podria considerarse pese a que es mas lenta, la implementación sobre listas antes que sobre arreglos. 

A modo de conclusión podemos decir en primer lugar que el las experiencias coincidieron con lo calculado teoricamente. Y por otro lado observamos como cada implementación de los nodos presenta sus ventajas y desventajas, razon por la cual para utilizar una u otra implementación debe considerarse el contexto donde se va a usar, es decir, a la hora de utilizar una u otra, es importante plantearse que es mas critico: si el tiempo de respuesta (nodos con arreglos) o la utilización de la memoria (nodos con listas).