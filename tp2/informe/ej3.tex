\part{Ejercicio 3}
\section{Enunciado}
Un radix tree o PATRICIA es un trie en el cual las cadenas de nodos con un solo hijo
son compactadas y transformadas en un solo nodo. Esto permite mejorar el consumo de
memoria de la estructura en el caso en que hay pocas cadenas definidas o que muchas
cadenas tengan prefijos largos en com'un.

Esta compactaci'on genera entonces las diferencias b'asicas entre los radix trees y los tries:

a) Todos los nodos internos de un radix tree tienen como m'inimo dos hijos (excepto
posiblemente la raiz).

b) Las ramas de un radix tree pueden estar etiquetadas con m'as de un caracter.
Si adem'as el conjunto (o del conjunto de claves del diccionario) es un conjunto libre
de prefijos, sucede que las cadenas (o los valores asociados a las claves) se encuentran
solamente en las hojas. Un conjunto libre de prefijos es aquel en el cual ningun elemento
es prefijo de otro.

Implementar un conjunto de cadenas basado en estas ideas que soporte las siguientes
operaciones:

a) Agregar una cadena al conjunto.

b) Consultar si una cadena pertenece al conjunto.

c) Sacar una cadena del conjunto.

d) Consultar la cantidad de cadenas del conjunto.

Donde las cadenas forman un conjunto libre de prefijos. Las tres primeras operaciones
deben tener complejidad O(ksk) donde s es la clave m'as larga ya definida y ksk indica la
longitud de s. La 'ultima operaci'on debe tener complejidad de orden constante.

El conjunto de caracteres sobre el que se van a definir las cadenas son las 26 letras min'uscu-
las del ingl'es.

\section{Desarrollo}
\subsection{PATRICIA}
Un Radix Tree o PATRICIA (Practical Algorithm To Retrieve Information Coded In Alphanumeric) es una estructura de datos 
basada en los Tries que suele cumplir el rol de diccionario. Sus claves son cadenas, y su significado es de tipo variado, 
d'andole uso para diferentes prop'ositos. La diferencia entre un PATRICIA y un Trie ya fue mencionada en el enunciado: 
un trie tiene un nodo por cada caracter de ua cadena, en cambio las ramas de un radix tree pueden estar etiquetadas con m'as de 
un caracter, y si adem'as el conjunto de claves es libre de prefijos, cada nodo del radix tendr'a almenos dos hijos.

\subsection{Sobre el dise\~{n}o de la estructura}
Por sus caracter'isticas, el PATRICIA presenta un amplio abanico de posibles implementaciones. Nosotros basicamente pensamos en tres formas:
\begin{itemize}
\item Con nodos formados por un arreglo (en este caso de 26 posiciones) que tiene ejes por elementos
\item con nodos formados por una lista de ejes 
\item con nodos que contienen una tabla de hash
\end{itemize}

Un eje es una tupla de puntero a un nodo hijo y una cadena adjunta. Los nodos pueden tener un bit que indica la validez o invalidez del 
mismo y/o el dato (significado) a guardar. En el caso de este TP, no se piden datos a guardar, por lo tanto optamos por implementar
los nodos con dos variantes de las ya nombradas: nodos formados por un arreglo de 26 posiciones con un bit de existencia y nodos 
formados por una lista con un bit de existencia. Como luego veremos, ambos dise\~{n}os de estructura cumplir'an las complejidades pedidas. 
El bit de existencia permite que podamos usar el patricia aun en casos donde el conjunto de entrada no este libre de prefijos, 
por ejemplo consideremos la figura \ref{fig:bitExistencia} en este caso si bien la forma del PATRICIA es la misma, 
mediante el bit de existencia podemos diferenciar si la palabra `emi' esta o no definida.

\begin{figure}[H]
\centering
\subfigure[La palabra emi no esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia.png} }\hspace{1in} 
\centering
\subfigure[La palabra emi si esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia1.png} }
\setcounter{subfigure}{0}
\caption{Utilización del bit de existencia}
\label{fig:bitExistencia}
\end{figure}

En cuanto al PATRICIA, se decidi'o que el mismo contendr'a nodos y no los definir'a dentro. O sea, separamos el objeto 'arbol 
PATRICIA del objeto nodo. Esto es as'i pues de este modo se implementa la modularidad que resulta de gran utilidad para 
implementar el PATRICIA para los diferentes tipos de nodo.

\subsection{Sobre el PATRICIA como 'arbol}
El enunciado presenta un invariante para el PATRICIA: 
\begin{itemize}
\item Todos los nodos internos de un radix tree tienen como m'inimo dos hijos (excepto
posiblemente la raiz).
\item Si adem'as el conjunto (o del conjunto de claves del diccionario) es un conjunto libre
de prefijos, sucede que las cadenas (o los valores asociados a las claves) se encuentran
solamente en las hojas. Un conjunto libre de prefijos es aquel en el cual ningun elemento
es prefijo de otro.
\end{itemize}
Este invariante deber'a conservarse durante todas las funciones.
PATRICIA nos sugiere un 'arbol formado de un conjunto de palabras dispersas en su estructura, como muestra el siguiente gr'afico.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/ej3/patricia.png}
\caption{Ejemplo de árbol patricia}
\end{figure}

Los nodos azules representan a las claves que pertenecen al conjunto. Este 'arbol se va formando a medida que agregamos y sacamos 
palabras del conjunto. A continuaci'on describiremos cuales fueron las pautas a seguir para armar dichas funciones.

\subsection{Agregando un elemento}
Cuando agregamos un elemento nos enfrentamos ante los siguientes casos:
\begin{itemize}
\item Se puede agregar el elemento sin tener que partir un eje

\begin{figure}[H]
\centering
\subfigure[PATRICIA original]{
\includegraphics[scale=0.4]{./figuras/ej3/patricia.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow.png} }
\centering
\subfigure[Bajamos lo m'aximo posible]{
\includegraphics[scale=0.4]{./figuras/ej3/patriciaCaravanaBajando.png} }
\centering
\subfigure[Patricia luego de agregar caravana]{
\includegraphics[scale=0.4]{./figuras/ej3/patriciaCaravana.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:noPartirNodo}
\end{figure}

\item Para agregar un elemento, hay que partir un eje y agregar un nodo

\begin{figure}[H]
\centering
\subfigure[PATRICIA original]{
\includegraphics[scale=0.4]{./figuras/ej3/patricia.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow2.png} }
\centering
\subfigure[Tenemos que partir el nodo de llana]{
\includegraphics[scale=0.4]{./figuras/ej3/partiendoNodo.png} }
\subfigure[Ahora que lo partimos podemos agregar la palabra como en el caso anterior]{
\includegraphics[scale=0.4]{./figuras/ej3/NodoPartido.png} }
\subfigure[Patricia luego de agregar avellaneda]{
\includegraphics[scale=0.4]{./figuras/ej3/patriciaAvellaneda.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:partirNodo}
\end{figure}

\end{itemize}

Para solucionar estos casos comenzaremos situ'andonos sobre la ra'iz. Luego bajamos por las ramas de la siguiente manera: en cada 
paso mantenemos guardada la palabra formada a partir de la concatenación de las cadenas adjuntas de los ejes por los cuales baj'e, 
y la cadena recortada que resulta de quitarle a la palabra el prefijo en com'un que tiene con cada eje por el cual baj'e. 

De esta forma en cada paso buscamos el eje tal que la primer letra de su cadena adjunta coincida con la primer letra de palabra 
recortada. As'i bajaremos por los ejes hasta que encontremos un eje que no sea prefijo, en su totalidad, de la cadena recortada, 
como se muestran los dos casos en las figuras \ref{fig:noPartirNodo}c y \ref{fig:partirNodo}c. Este algoritmo no presenta 
ambiguedades a la hora de buscar el eje por el cual bajar, pues cada nodo tiene un m'aximo de 26 hijos, correspondientes a las 26 
letras del abecedario ingl'es, y no puede tener mas de un eje que su cadena adjunta comience con la misma letra. O sea, no puede 
haber nodos con, por ejemplo, ejes con cadenas casa y cosa.

Una vez que bajamos por las ramas lo m'aximo posible, si la palabra formada es prefijo de la palabra a agregar, quiere decir que 
caimos en el primer caso. Este caso es simple y solo resta agregar el nodo y el eje correspondiente, con la clave sin prefijo, 
como se muestra en la figura \ref{fig:noPartirNodo}, gr'afico d.

Supongamos ahora que se desea agregar avellaneda. Bajamos por las ramas. Si la palabra formada no es prefijo de la clave a 
definir, este es el segundo caso, pues esto querr'a decir que el 'ultimo eje tiene letras que son parte de la clave y otras que 
no lo son. Entonces haremos lo siguiente: partimos el 'ultimo eje (ver figura \ref{fig:partirNodo}, gr'afico c) y crearemos un 
nuevo padre para el nodo en el cual quedamos, de manera que la primera parte del 'ultimo eje (la que tiene letras en com'un con 
la clave) quedar'a adjunta a un eje que apunte desde el padre anterior hacia el nuevo padre, y la cadena restante del eje partido 
quedar'a adjunta al eje que le apunta desde el nuevo padre (ver figura \ref{fig:partirNodo},gr'afico d). Finalmente, para 
reestablecer el invariante, agregamos un nuevo nodo y un nuevo eje, apuntando del nuevo padre al nuevo nodo hijo, que tenga 
adjunto la parte restante de la clave (ver figura \ref{fig:partirNodo}, gr'afico e).

Excediendo el l'imite del enunciado, nuestro algoritmo agregar podr'a tener en cuenta conjuntos de entrada que no sean libre de 
prefijos, sin alterar el producto pedido. Esto nos agregar'a dos casos m'as: 
\begin{itemize}
\item Para agregar un elemento hay que simplemente setear el bit de existe

\begin{figure}[H]
\centering
\subfigure[La palabra emi no esta definida]{
\includegraphics[scale=0.4]{./figuras/ej3/bitDeExistencia.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow3.png} }
\centering
\subfigure[La palabra emi si esta definida]{
\includegraphics[scale=0.4]{./figuras/ej3/bitDeExistencia1.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:seteaExiste}
\end{figure}

\item Para agregar un elemento hay que partir un eje y setear el bit de existe
\end{itemize}
\begin{figure}[H]
\centering
\subfigure[Bajando por el 'arbol original para agregar cosa]{
\includegraphics[scale=0.4]{./figuras/ej3/BajandoPartirYExiste.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow4.png} }
\centering
\subfigure[Parto el eje y seteo bit de existe]{
\includegraphics[scale=0.4]{./figuras/ej3/PartoUnEjeYSeteoExiste.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:parteYSeteaExiste}
\end{figure}

Estos dos nuevos casos en realidad podemos resolverlos como derivados de los dos anteriores. Si al bajar por las ramas, la 
palabra formada es prefijo de la clave, y la clave es prefijo de la palabra formada, caemos en el primer caso. En este caso 
simplemente se setea el bit de existe al nodo en el cual caimos, como lo muestra la figura \ref{fig:seteaExiste}.

Si al bajar por las ramas, la clave es prefijo de la palabra formada y la palabra formada es m'as larga que la clave, caemos en el 
segundo caso. Este problema se resuelve partiendo el eje y creando un nuevo nodo en medio del eje a partir. Ahora la primer parte
 del eje partido apuntar'a al nuevo nodo, y la parte restante apuntar'a desde el nuevo nodo hacia el nodo en el cual caimos al bajar, como lo muestra la figura \ref{fig:parteYSeteaExiste}.
Claramente los dos primeros casos correspondientes al enunciado son excluyentes con estos dos 'ultimos casos, pues los primeros agregan solo nodos hojas, los segundos agregan solo nodos internos. Esto me asegura que el producto pedido no ser'a cambiado.

\subsection{Eliminando un elemento}
Cuando eliminamos un elemento nos enfrentamos ante los siguientes casos:
\begin{figure}[H]
\centering
\subfigure[PATRICIA]{
\includegraphics[scale=0.4]{./figuras/ej3/SeBorraLaHojaYNoSeMergea1.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow5.png} }
\centering
\subfigure[Bajamos lo m'aximo posible]{
\includegraphics[scale=0.4]{./figuras/ej3/SeBorraLaHojaYNoSeMergea2.png} }
\centering
\subfigure[Patricia luego de sacar dama]{
\includegraphics[scale=0.4]{./figuras/ej3/SeBorraLaHojaYNoSeMergea3.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:borroYNoMergea}
\end{figure}

\begin{figure}[H]
\centering
\subfigure[PATRICIA original]{
\includegraphics[scale=0.4]{./figuras/ej3/patricia.png} }
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow6.png} }
\centering
\subfigure[Bajamos lo m'aximo posible]{
\includegraphics[scale=0.4]{./figuras/ej3/BorroHojaYMergeo1.png} }
\centering
\subfigure[Patricia luego de sacar dato]{
\includegraphics[scale=0.4]{./figuras/ej3/BorroHojaYMergeo2.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:borroYMergea}
\end{figure}
Para solucionar estos casos comenzamos situ'andonos sobre la ra'iz, y bajando, al igual que agregar. Gracias a que el conjunto
 de entrada es libre de prefijos, sabemos que al sacar una clave siempre eliminaremos una hoja del 'arbol. De esta manera, en 
 caso de querer eliminar una clave existente, esta siempre ser'a una hoja, como lo muestra el siguiente gr'afico:
 
[Grafico bajando por rama para sacar(dama)] 8

Al borrar la hoja, debemos verificar cuantos hermanos ten'ia. Si ten'ia m'as de un hermano, caeremos en el primer caso, 
el cual se resuelve simplemente eliminando la hoja y su eje, como lo muestra el gr'afico \ref{fig:borroYNoMergea}. Si, por el contrario, ten'ia solo 
un hermano, al borrar este nodo al padre le restar'a un solo hijo, como lo muestra la figura. Para reestablecer el invariante, 
como la rama hasta el nodo padre no conforma una clave definida, podemos unir el padre con su 'unico hijo. Lo hacemos simplemente
 borrando el nodo hijo y concatenando el eje que apunta del nodo abuelo al nodo padre con el eje que apunte del nodo padre al
 nodo hijo, como lo muestra el grafico \ref{fig:borroYMergea}.

Excediendo el l'imite del enunciado, nuestro algoritmo sacar podr'a tener en cuenta conjuntos de entrada que no sean libre de 
prefijos, sin alterar el producto pedido. Esto nos agregar'a dos casos m'as: 
\begin{itemize}
\item Para sacar un elemento hay que setear FALSE el bit de existe
\begin{figure}[H]
\centering
\subfigure[La palabra emi esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia1.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow7.png} }\hspace{1in} 
\centering
\subfigure[La palabra emi no esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/bitDeExistencia.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:casoExtraSacarA}
\end{figure}

\item Para sacar un elemento hay que concatenar dos ejes y borrar un nodo

\begin{figure}[H]
\centering
\subfigure[La palabra emi esta definida]{
\includegraphics[scale=0.5]{./figuras/ej3/casoExtraSacar1.png} }\hspace{1in} 
\centering
\subfigure[ ]{
\includegraphics[scale=0.2]{./figuras/ej3/arrow8.png} }\hspace{1in} 
\centering
\subfigure[PATRICIA luego de eliminar emi]{
\includegraphics[scale=0.5]{./figuras/ej3/casoExtraSacar2.png} }
\setcounter{subfigure}{0}
\caption{}
\label{fig:casoExtraSacarB}
\end{figure}

\end{itemize}
Estos dos nuevos casos son consecuencia directa de los casos de entrada que no esta libre de prefijos de agregar. 
Luego de bajar por las ramas del 'arbol verificamos que la palabra armada es igual a la clave y el nodo existe. De esta forma nos
 aseguramos que la clave a borrar haya sido definida. Si el nodo a borrar es un nodo interno (no es una hoja), caemos en alguno
 de estos dos casos. Si el nodo a borrar tiene mas de un hijo, caemos en el primer caso. Este se soluciona seteando el bit de 
 existencia del nodo a falso, como muestra la figura \ref{fig:casoExtraSacarA}. Si el nodo a borrar tiene solo un hijo, este es
 el segundo caso. Se resuelve borrando el nodo padre y concatenando el eje que apuntaba del nodo padre al nodo actual, y el eje
 del nodo actual al nodo siguiente, como lo muestra la figura \ref{fig:casoExtraSacarB}.
 
Claramente estos dos casos son excluyentes con los dos primeros correspondientes al enunciado, pues los primeros borran solo 
nodos internos, los segundos borran solo hojas. Esto me asegura que el producto pedido no ser'a cambiado.


\subsection{Detalles de implementacion de los nodos}
Aclaraciones sobre los miembros privados de la estructura: para implementar las listas (para los nodos que las usan) usamos Standard Template Library (STL). Fueron definidas 2 (dos) variables auxiliares: existe y cantElem. Si bien aislando el nodo como estructura independiente el booleano "existe" puede carecer de sentido, lo adquiere al implementar el PATRICIA, ya que sin ella no podriamos diferenciar los elementos definidos de los no definidos. En cuanto a cantElem, solo existe para nodo sobre arreglos. La variable se agrega para informarnos la cantidad de hijos que tiene el nodo, y se contabiliza a medida que se agregan y sacan nodos hijos. No lo necesitamos para los nodos sobre listas, pues contamos con la funcion size de STL list.
La implementaci'on de nodos sobre arreglos cuenta con un arreglo de apuntadores a eje.
A continuaci'on explicaremos detalladamente cada funci'on referente a los nodos:
\begin{itemize}
\item constructor: inicializa el booleano existe a FALSE. En caso de nodo sobre arreglo, inicializa adem'as cantElem a 0 (cero) y todo el arreglo a NULL.
\item agregar: toma por par'ametro una referencia constante a cadena y un opcional apuntador a nodo. Adhiere un nuevo nodo al conjunto de hijos del nodo en cuesti'on. Lo hace asign'andole un eje que tiene un puntero al nuevo nodo y una cadena adjunta. Si el nodo es pasado por par'ametro, el eje apuntar'a hacia ese nodo. Caso contrario se crear'a un nuevo nodo sin nodos hijos, con el bit existe en TRUE, y el eje apuntar'a hacia el nuevo nodo. Esto es as'i a causa de efectos pr'acticos a la hora de implementar el PATRICIA. Para el caso de los nodos sobre arreglos, a la i-esima letra del abecedario ingl'es le corresponde la i-esima posici'on del arreglo. En caso de los nodos sobre listas, los ejes son agregados en orden ascendiente por cadena.

\item sacar: toma por par'ametro una referencia constante a cadena. Borra el eje adjunto a la cadena pasada por par'ametro. No borrar'a el nodo apuntado por el eje borrado. Esto, en cambio, ser'a tarea del PATRICIA. Para el caso de los nodos sobre arreglos, borrar el eje es trivial si indexamos el arreglo  sobre la primer letra del par'ametro. En cambio, para los nodos sobre listas, se deber'a iterar sobre la lista hasta encontrar el eje a borrar.

\item pertenece: toma por par'ametro una referencia constante a cadena. Verifica si existe un eje adjunto a la cadena pasada por par'ametro. Para los nodos sobre arreglos, indexamos el arreglo sobre la primer letra del par'ametro y verificamos la igualdad. Para los nodos sobre listas, iteramos sobre la lista hasta encontrar la cadena buscada. Para ambos casos, si no se encuentra un eje adjunto a la cadena, se devuelve NULL.

\item ejeQueEmpiezaCon(cadena): toma por par'ametro una referencia constante a cadena. Requiere que la cadena sea de longitud 1 (uno). Caso contrario devolver'a NULL. Devuelve un puntero a eje que tiene por primer letra el parametro. Para nodo sobre arreglos, simplemente se indexa sobre la letra del par'ametro. Para nodo sobre listas, se itera sobre la lista de ejes, hasta encontrar una coincidencia entre la primer letra de la cadena adjunta al eje iterado con el par'ametro. Si no existe tal eje, se devuelve NULL.

\item iesimoEje(entero): toma por par'ametro un entero sin signo $n$. Devuelve un apuntador a eje. Para nodo sobre arreglos, se indexa el arreglo sobre el entero pasado par'ametro. Para nodo sobre listas, se itera sobre la lista de ejes, hasta iterar $n$ veces. Si no existe tal eje, se devuelve NULL.

\item primerEje: no toma par'ametros. Devuelve un apuntador al primer eje encontrado. Para nodo sobre arreglos, se busca de 0 a 26 un eje definido. Para nodo sobre listas, se devuelve el primer elemento de la lista.

\item cantHijos: no toma par'ametros. Devuelve el cardinal del nodo, entendi'endose por cardinal la cantidad de hijos que tiene. En realidad esta funci'on no hace mas que devolver el valor de la variable cantElem.

\item esHoja: no toma par'ametros. Devuelve TRUE o FALSE indicando si el nodo no tiene ningun nodo hijo o tiene alguno, respectivamente. Simplemente se compara cantElem con 0.

\item destructor: para nodo sobre arreglo, recorre el arreglo eliminando eje por eje (NO borra los nodos hijo). En caso de nodo sobre lista, no hace absolutamente nada.
\end{itemize}

\subsection{Detalles de implementacion del 'arbol PATRICIA}
Aclaraciones sobre la clase: el PATRICIA es amigo de la clase nodo y adem'as lo contiene. Necesita ser amigo para tener acceso a la creaci'on de ejes y uso de los metodos privados.
Aclaraciones sobre la variable privada: aqu'i tambi'en tenemos una variable llamada cantElem, que contabilizar'a la cantidad de elementos definidos en el conjunto de cadenas. Esta variable nos permitir'a cumplir con las complejidades pedidas, como se explica en la secci'on de c'alculo de la complejidad.
\begin{itemize}
\item constructor: inicializa cantElem a 0 (cero) y la raiz, sete'andole TRUE a su valor existe.

\item destructor: hace un recorrido postorder sobre el 'arbol: primero recorre la lista de hijos, llamando recursivamente, y luego borra el nodo actual.

\item agregar: toma por par'ametro una referencia constante a cadena. Se baja por las ramas con el m'etodo bajar. Se verifica si la palabra armada es igual a la cadena y si el nodo existe. Si esto se cumple, terminar'a, pues quiere decir que la palabra ya estaba definida, sino sigue su ejecuci'on. A partir de este paso, sabemos que hay un elemento que ser'a agregado, pues es un elemento no existente en el conjunto. Luego se toma la cadena pasada por par'ametro y la palabra armada, y se les quita el prefijo. Esto lo hacemos pues as'i podemos ver si debemos partir el eje o no, ya que si la palabra armada, que es la concatenaci'on de todos los ejes por los que baj'e, no es prefijo de la cadena, quiere decir que el 'ultimo eje no coincid'ia totalmente con la parte de la cadena sin prefijo. Verificamos entonces si la palabra armada es vac'ia luego de sacarle el prefijo, si no lo es, partimos el eje y creamos un nuevo padre para este nodo. Si era vacia, no hacemos nada. Luego dependiendo si se partio el eje o no, colgamos el nuevo nodo del nuevo padre o del nodo en el que quedamos luego de bajar, y a ese eje le adjuntamos la parte sin prefijo de la cadena, con el m'etodo agregar de nodo. Finalmente se incrementa la variable cantElem, sin importar en qu'e caso entr'o, pues antes hab'iamos comprobado si la cadena a agregar no est'a definida en el conjunto.

\item sacar: toma por par'ametro una referencia constante a cadena. Se baja por las ramas con el m'etodo bajar. Se verifica si se logr'o encontrar la cadena comparandola en relaci'on de igualdad con la palabra armada, y si el nodo existe. Si esto se cumple, el algoritmo sigue su ejecuci'on, sino termina. Nuevamente decimos que a partir de este paso, sabemos que hay un elemento que ser'a eliminado. Para este m'etodo resulta necesario el retorno de bajar, el eje anterior al eje actual (el que va del abuelo al padre del nodo actual), pues este nos permite resolver casos de uni'on de ejes cuando el padre del actual tiene dos hijos o menos. Empezamos por resolver los casos que el enunciado nos da: aquellos que borramos una hoja. Si el actual es hoja, lo borramos, junto con su eje, y verificamos lo siguiente: si exist'ia un nodo anterior (no se est'a borrando ning'un elemento que esta colgado de la raiz) y el anterior no existe y, luego de borrar la hoja, tiene 1 hijo, entonces tenemos que unir los ejes anterior y el eje que va del padre al 'unico hermano del nodo borrado. Los casos restantes son aquellos que se debe borrar un nodo interno. Estos se contemplan entre todo el conjunto de casos que son disjuntos con el anterior (aquellos en los que se borran hojas). Se comienza preguntando si el nodo actual tiene un unico hijo, pues debemos evitar podar toda una rama del 'arbol incorrectamente. En este caso, se concatenan los ejes del padre del actual al actual, y del actual al hijo del actual. Luego se procede a borrar el actual. Si el actual tenia m'as de un hijo, se setea el bit existe a FALSE. Finalmente se decrementa la variable cantElem en uno. Es importante notar que la variable decrementa sin importar en qu'e caso entr'o, pues antes hab'iamos comprobado si la cadena a borrar est'a definida en el conjunto.

\item pertenece: toma por par'ametro una referencia constante a cadena. Devuelve un booleano. Se procede bajando por el 'arbol con el m'etodo bajar, y se verifica si se logr'o encontrar la cadena comparandola en relaci'on de igualdad con la palabra armada, y si actual existe.

\item cardinal: no toma par'ametros. Devuelve un entero positivo. Esta funci'on devuelve el valor de cantElem.

\item bajar: toma por par'ametro una referencia a puntero a nodo, una referencia a puntero a eje, una referencia constante de cadena, y una referencia a cadena. Devuelve un puntero a eje. El primer par'ametro corresponde al nodo actual, y funciona como variable para devolver resultados. Al algoritmo no le interesa lo que le manden en esa variable, pues al entrar define actual como raiz. An'alogamente, el segundo par'ametro funciona tambi'en como variable de retorno del eje actual (el que apunta al nodo actual) y el algoritmo asigna su valor al entrar a la funci'on. El tercer par'ametro es la cadena que se le pasa por par'ametro a agregar y a bajar. El cuarto par'ametro es la palabra armada, que es la concatenacion de todas las cadenas adjuntas a los ejes por los cuales bajaremos. A este par'ametro tambi'en se le asigna un valor, que es la cadena vac'ia, apenas se llama la funci'on. Este m'etodo tiene como fin ser reciclable: puede ser usado para bajar por el 'arbol, sin importar el caso para el cual se lo quiere usar, sea agregar, sacar o verificar pertenencia.
Bajar define cuatro variables auxiliares: puedeBajar (bool), recortada (string), aux (puntero a eje) y ejeAnterior (puntero a eje). La primera define si el algoritmo puede seguir bajando o no por las ramas del 'arbol, la segunda sirve para guardar la parte que falta por recorrer del tercer argumento, la tercera sirve para mirar a los ejes antes de bajar, y la cuarta guarda el valor de ejeActual (segundo par'ametro) antes de ser cambiado. El m'etodo comienza llamando a actual.ejeQueEmpiezaCon d'andole la primer letra de recortada (que al principio coincide con la primer letra del tercer par'ametro). Si existe tal eje, se asigna TRUE a puedeBajar. Sino, el algoritmo finaliza. Si es cierto que se puede bajar, se procede a hacerlo actualizando los valores de eje anterior, eje actual, nodo actual, la palabra armada, la palabra recortada y puedoBajar. A puedoBajar se le asigna TRUE si el eje actual es prefijo (completo) de recortada. Sino se le asigna falso. Este procedimiento se ejecuta hasta que puedoBajar sea falso, sea porque lleg'o a una hoja o porque el eje que contiene eje actual no es totalmente prefijo de recortada.

\item quitarPrefijoEnComun: toma por par'ametro una referencia a cadena y una referencia constante a cadena. Recorre letra por letra de los par'ametros, hasta que alguno de los dos llegue al final, y guarda un contador de cu'antas letras recorri'o. Al finalizar, le borra al primer par'ametro desde el principio de la cadena hasta contador. La funci'on devuelve TRUE si la longitud del segundo par'ametro es igual al valor de contador, o sea devuelve true si el segundo par'ametro es prefijo del primero. Caso contrario, devuelve FALSE.
\end{itemize}

\section{Pseudoc'odigo}
\input{pseudo3}
\newpage

\section{Cálculo de complejidad}
Para realizar el analisis de la complejidad vamos a considerar el modelo uniforme ya que las principales operaciones se realizan a nivel de caracteres, por lo cual podemos considerar que tienen un costo acotado. Ahora bien, con respecto al tamaño de la entrada, en este caso consideramos que es la cantidad de caracteres que componen a la cadena sobre la que se va a operar, ya sea para agregarla, borrarla o saber si esta definida. Llamos s a la cadena de entrada, y $long_s$ a el largo (cantidad de caracteres) de la misma

A continuación analizaremos las cuatro funciones que debíamos implementar, para determinar el orden de complejidad logrado en cada una.

\subsection{Agregar}
Lo primero que hacemos es bajar por las ramas mientras entonctremos prefijo para s (cada vez que pasamos por un eje que es prefijo, le quitamos esa parte a s). En cada eje comparamos una porción de s, que al pasar al siguiente eje no se toca. Por esta razón cada caracter de s se va a tocar a lo sumo una vez. Cuando estamos en un nodo, debemos encontrar el eje hacia donde nos vamos a mover. Si el nodo cuenta con un arreglo de ejes, esto se hace en O(1).

Por otro lado, con las listas ocurre lo mismo, ya que a lo sumo hay 26 caracteres, es decir 26 ejes de salida para el nodo. Por lo tanto, como es una cantidad acotada por una constante, recorrer esa lista también es O(1). Luego llegar hasta la posición donde debemos agregar a s, nos costo hacer a lo sumo $long_s$ busquedas de ejes, con un costo O(1), por lo tanto tenemos un costo $O(long_s)$. 

Notemos que en general hacemos menos busquedas de nodos, ya que en un eje suele haber varios caracteres. Sin embargo, hay que comparar el string del eje con s, por lo que en definitivda se terminan haciendo menos busquedas pero en ellas se hacen comparaciones de varios caracteres.

A medida que bajamos, vamos guardando la cadena que se va formando. Armar dicha cadena consiste en ir juntando los strings de cada eje, nuevamente el costo es $O(long_s)$. 

Si la palabra ya estaba en el conjunto, no hacemos nada y terminamos. El costo fue en total $O(long_s)$.

Si en cambio la palabra no estaba, lo proximo que hacemos es eliminar los prefijos comunes entre s y la palabra armada durante el descenso, nuevamente para hacer esto, recorremos a lo sumo $long_s$ caracteres. 

Si hay que partir el nodo, lo que se hace es partir la cadena del ultimo eje visitado en la parte que es igual a s y la parte que difiere. Nuevamente, vamos a recorrer como mucho $long_s$, msa no podemos porque a partir del caracter $long_s$ + 1 no hay caracter en s con el cual comparar.

Una vez que partimos esta cadena creamos un eje nuevo, que se hace en O($long_max$) donde $long_max$ es el tamaño de la mayor palabra en el patricia porque si armamos un eje nuevo hay que copiar la parte de la cadena del eje, que no era prefijo en s, y esa parte de la cadena puede ser mas larga que s, por esa razon es O($long_max$) y no O($long_s$). Tambien creamos un nuevo nodo, que se hace en O(1).

Luego de esto, linkeamos los nodos mediante el eje antes creado. Y seteamos el valor de existencia del nodo. Estas acciones se hacen en O(1), lo primero es setear un puntero y lo segundo es asignar un bool.

Despues de esto, si hay que agregar un nuevo eje para s, se hace, pero esta vez el costo es O($long_s$). Se crea un nuevo nodo y se linkea con el nodo hasta donde habia bajado en O(1).

Si no habia que partir nodo, ni agregar un nodo nuevo, solo se setea el bit de existe en el ultimo nodo que visite.

Por ultimo si la palabra no estaba ya en el conjunto, incrementamos en uno el cardinal del conjunto

Luego tenemos una cantidad acotada de operaciones de costo O($long_s$) y O($long_max$). Ahora bien, como $long_max \geq long_s$, O($long_s$) $\subset$ O($long_max$). Por lo tanto, el orden del algoritmo tiene un orden O($long_max$)

\subsection{Sacar}
Primero bajamos mientras en los ejes encontremos prefijo de s. Como vimos antes, esto se hace en $O(long_s)$. 
 
Si el nodo a borrar es una hoja, eliminamos el nodo y al eje correspondiente. Borrar el eje, tiene $O(long_s)$ porque dicho eje, era subcadena de s. 

Una vez hecho esto, podria ser necesario, si el padre tiene ahora solo un hijo, combinar el string del eje que llega al padre con el de su hijo. Esto se hace en O($long_max$) ya que no sabemos a priori que tan largo puede ser la cadena del eje del `hermano` de s.

Si no era una hoja y tiene solo un hijo lo que hacemos es borrar el nodo, y combinar los ejes de él con su padre y de él con su unico hijo. Nuevamente el costo de esto es O($long_max$).

Si no era hoja y no tenia solo un hijo, lo que hacemos es setear su flag de existe en false, que se hace en O(1). 

Si la palabra estaba definida, lo ultimo que hacemos es decrementar en uno el cardinal del conjunto.

Luego el orden de esta operacion es  O($long_max$)

\subsection{Pertenece}
Al igual que con las dos operaciones anteriores, lo que hacemos es bajar mientras encontremos en los ejes, prefijos de s. Esto, como dijimos anteriormente tiene costo $O(long_s)$. Una vez que bajamos, comparamos la cadena obtenida durante la bajada, con s. La cadena se obtiene en $O(long_s)$ mientras bajamos, y la comparació se hace también en $O(long_s)$. 
Por otro lado se pregunta si el nodo existe, pero esta operacion la realizamos en O(1).

Como $long_max \geq long_s$, vale que $O(long_s)$$\subset$ O($long_max$), luego la operación es O($long_max$)

\subsection{Cantidad de elementos}
Como cada vez que guardamos o sacamos una palabra actualizamos el cardinal del conjunto, en caso de que se solicite la cantidad de palabras del conjunto, se devuelve este contador, sin tener que hacer mas operaciones, por lo tanto la operacion es O(1).
