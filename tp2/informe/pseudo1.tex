\begin{algorithm}
\caption{Devuelve la lista de aquellos jugadores, tal que se puede arreglar el torneo}
\label{alg:algoritmo1}
\begin{algorithmic}[1]
\PARAMS {Grafo con jugadores como nodos, y partidos arreglados como aristas direccionadas}
\IF{hay menos partidos arreglados que jugadores \textcolor{orange}{$-$} 1}
	\RETURN \textcolor{orange}{[ ]}
\ENDIF
\STATE DFS numerando todos los nodos por fin de llamada recursiva
\STATE hacer DFS solo para el nodo de mayor numeración
\STATE aCuantosLlega $\textcolor{orange}{\leftarrow}$ cantidad de nodos tocados en el DFS anterior
\IF{aCuantosLlega $\textcolor{orange}{==}$ todos los nodos del grafo}
	\STATE hacer DFS desde el nodo pero con las aristas de salida
	\STATE ganadores $\textcolor{orange}{\leftarrow}$ todos los nodos tocados por el dfs anterior
	\STATE ordenar(ganadores) \COMMENT{ lo hago con bucketSort porque los ganadores estan entre 1 y cantidad de nodos}
\ELSE
	\RETURN \textcolor{orange}{[ ]}
\ENDIF
\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}
\caption{numera nodos, guarda quien el que tiene el valor mas alto (cantidad de nodos -1)}
\label{alg:algoritmo1b}
\begin{algorithmic}[1]
\PARAMS{un grafo, un nodo del grafo, un contador que se modifica, un marcador de nodos visitados}
\PARAMS{una variable que se modifica y guarda el nodo de max valor}
\FOR{cada nodoAdyacente tal que nodo $\leadsto$ nodoAdyacente}
	\IF{ no lo visite}
		\STATE dfs(grafo,nodoAdyacente,contador,visitados,masValioso)
	\ENDIF
\ENDFOR
\IF{a este nodo le toca el valor mas alto}
	\STATE valioso $\textcolor{orange}{\leftarrow}$ nodo
\ENDIF
\STATE incrementar el contador
\end{algorithmic}
\end{algorithm}

Esta funcion debe llamarse con el contador inicializado en cero
y todos los visitados en false. Cada vez que termina, si no se visitaron todos
debe ser llamada de nuevo, manteniendo el contador y los visitados.

Los otros algoritmos que hacen dsf no se detallan en esta sección ya que el pseudocodigo de los mismos es muy similar
al anterior.
El algoritmo que realiza dfs para ver a cuantos llego, es muy similar a este ultimo
solo que no se numeran nodos, sino que se cuenta a cuantos toco desde el nodo donde empiezo
De forma similar el algoritmo que realiza dfs en reverso, hace los mismo pero en vez de numerar
guarda cada nodo que visita en una lista, y en vez de usar los otros nodos tal que nodo $\leadsto$otro nodo
se mueve hacia los otros nodos tal que otor nodo $\leadsto$nodo 