\chapter{Ejercicio 1}
\section{Enunciado}
Un torneo de Tenis de eliminaci'on simple consiste en varios partidos donde el perdedor de
cada partido es eliminado del torneo y no vuelve a jugar un partido en ese torneo. El fixture
del torneo se arma al comienzo del mismo tomando dos jugadores a'un no eliminados para
cada partido, hasta que quede s'olo un jugador no eliminado, que resulta ser el ganador.

Con este esquema de fixture no s'olo la destreza o el entrenamiento entran en juego para
decidir el ganador sino que la suerte tiene un papel importante.

Despu'es de observar el entrenamiento de los participantes hay ciertos partidos de los
cuales se puede saber con certeza su resultado, es decir, para ciertos jugadores a,b, se
puede asegurar que a le gana a b.

Diremos que el torneo puede ser arreglado para que gane x si existe un fixture de elimi
naci'on simple donde se puede asegurar que gane x.
Encontrar todos los participantes x para los cuales el torneo puede ser arreglado para gane
x.

Modelar este problema utilizando grafos. Justificar el modelo.

El mejor algoritmo que conocemos es de O(n + m).

\section{Desarrollo}
\subsection{Sobre el modelo}
Para resolver el problema, planteamos un dígrafo donde cada nodo es un jugador y a$\leadsto$b si  a le gana a b. 

Lo primero que observamos es que la relación de ganar, por como esta planteada, es transitiva. Decimos que es transitiva en el sentido de que si a$\leadsto$b y b$\leadsto$c, se puede hacer que a le gane a c, haciendo que b le gane a c y luego a le gane a b. Es decir, si bien no vale que a$\leadsto$c, se puede organizar los partidos para que a pueda ganar. En general, durante el desarrollo, usaremos que a gana, o puede ganar como sinonimos de se puede armar un torneo.

Entonces según este modelo, un jugador, jugador A, puede ganar si para cada uno de los otros jugadores, jugador B, existe un 
camino dirigido que comunica a A con B. Sea C el camino que comunica A y B, C=A, $V_1$, $V_2$, ...$V_{k-1}$,$V_k$, B. Podemos entonces armar el fixture de la siguiente manera: primero juegan $V_k$ y B, como hay camino sabemos que $V_k$ $\leadsto$ B, entonces $V_k$ le gana a B. Luego hacemos que $V_{k-1}$ le gane a $V_k$, y asi seguimos hasta que A juegue con $V_1$ y le gane.

Por ejemplo, si miramos la figura ~\ref{fig:conGanador}, ese digrafo nos representa un torneo donde sabemos que:
\begin{itemize}
\item 1$\leadsto$2
\item 1$\leadsto$4
\item 2$\leadsto$5
\item 2$\leadsto$6
\item 4$\leadsto$3
\item 4$\leadsto$6
\end{itemize}

Entonces podemos arreglar el torneo para que gane el jugador 1, jugando los siguientes partidos, en el siguiente orden:
\begin{enumerate}
	\item 5 vs 2
	\item 4 vs 6
	\item 4 vs 3
	\item 1 vs 2
	\item 1 vs 4
\end{enumerate}

Luego si usamos esto, podemos obtener una primera forma de resolver el problema: Para 
cada nodo, tratamos de recorrer todo el digrafo. Si lo logramos, sabemos que se puede armar un torneo para que gane. Como esto se hace para 
cada nodo, el orden queda $O(n*m)$. 

Por otro lado, podemos ver que para que exista un ganador es necesario que si participan n jugadores, la cantidad de partidos arreglados sea como mínimo n - 1, ya que con menos partidos, es imposible que desde un jugador se pueda alcanzar a todos los dem'as. De modo que obtenemos una caracter'istica que permite resolver un tipo de instancia particular muy f'acilmente.

Buscamos entonces alguna forma de mejorar el orden. Una primera alternativa era guardar 
alguna información en cada recorrida, para no repetir cálculos, pero los ciclos nos impedían lograr alguna solución. Tuvimos  entonces que buscar alguna otra forma.

\subsection{Resolucion en digrafos ac'iclicos}
Si el digrafo que se obtiene no presenta ciclos, se puede ver que existe un ganador si y solo si existe un único nodo tal que su 
grado de entrada es 0. 

Lo que ocurre es que si el grado de entrada de solo un nodo es 0, entonces existe un camino dirigido desde dicho nodo a cualquier otro(ver demostración 1). Por otro lado, si no hay ciclos y existe un ganador, a este no le puede ganar nadie, por lo tanto su grado de entrada es 0.

Por ejemplo, el digrafo de la figura ~\ref{fig:conGanador}:

\begin{figure}[H]

\centering
\includegraphics[scale=0.5]{./figuras/ej1/ConGanador.png}
\caption{Ejemplo con un solo nodo con grado de entrada nulo}
 \label{fig:conGanador}
\end{figure}

En este caso, solo puede haber un ganador, el jugador 1.

Si existen varios, no se podrán eliminar nunca, ya que no hay quien les gane con seguridad. Por ejemplo, lo digrafos de la figura ~\ref{fig:sinGanador}:

\begin{figure}[H]
    \begin{minipage}{.5\linewidth}
    \centering
     \includegraphics[scale=0.5]{./figuras/ej1/SinGanador1.png}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
    \centering
      \includegraphics[scale=0.5]{./figuras/ej1/SinGanador2.png}
    \end{minipage}
 \caption{Ejemplos con mas de un nodo con grado de entrada nulo}
    \label{fig:sinGanador}
\end{figure}
\afterpage{\clearpage}
En el primer caso, el 5 y el 1 no se pueden eliminar. Análogamente, en el segundo caso, 1 y 6 no se pueden eliminar en ningún momento.
Por otro lado, no puede ocurrir que no halla ning'un nodo con grado de entrada 0, porque si eso ocurre existe un ciclo. (Ver 
demostración 2).

Entonces si no hay ciclos, podemos resolver fácilmente el problema: Si representamos el digrafo con listas de adyacencia (tanto 
de entrada, como de salida), podemos mirar cada nodo, viendo si hay solo uno con grado de entrada 0. Si es así, ese gana. Si 
encontramos varios, no existe ganador. Esto tiene como costo O(n), ya que recorremos todos los nodos, y preguntamos cuanto mide 
su lista de adyacencia de salida (costo constante).

Ahora bien, no se puede afirmar que el digrafo que recibimos no presente ciclos. Es decir hay instancias validas que poseen 
ciclos, por ejemplo la figura ~\ref{fig:conCiclo}:


\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/ej1/ConCiclo.png}

\caption{Ejemplo sin ning'un nodo con grado de entrada 0}
\label{fig:conCiclo}
\end{figure}

En este caso, el torneo puede arreglarse tanto para 1, como para 2, 4 o 5. Debemos entonces buscar alguna manera de salvar esta dificultad.

\subsection{El papel de las componentes fuertemente conexas}
Si tenemos ciclos, no vale la propiedad antes enunciada sobre los grados de entrada.

Analizamos entonces que ocurre si el digrafo presenta un ciclo. Como la relación a$\leadsto$b es transitiva (en el sentido que 
comentamos antes), todos los elementos que pertenecen a un ciclo, se ganan entre si, pues para cualquiera de ellos existe un camino hacia cualquier otro elemento del ciclo y como vimos eso significa que les puede ganar. Por otro lado, si tomamos un elemento que 
no este en el ciclo (a) y que le gane a alguien del mismo (b), podemos ver que les puede ganar a todos: primero hacemos que b 
le gane a todos otros del ciclo, y luego hacemos que a le gane a b. Análogamente se puede ver que si alguien del ciclo, le gana a 
alguien que no esta en el; cualquier otro del ciclo le puede ganar.

Esto nos hace pensar que podemos considerar al cada ciclo como una unidad, como un jugador único, que les gana a todos 
aquellos que son derrotados por algún individuo del ciclo y que pierde contra todos aquellos que le ganan a alguien del ciclo.

\begin{figure}[H]
    \begin{minipage}{.5\linewidth}
    \centering
     \includegraphics[scale=0.5]{./figuras/ej1/componentesConexas.png}
    \end{minipage}
    \begin{minipage}{.5\linewidth}
    \centering
      \includegraphics[scale=0.7]{./figuras/ej1/reducido.png}
    \end{minipage}

 \caption{Ejemplo de reducci'on de un digrafo}
 \label{fig:reduccion}
\end{figure}
%\afterpage{\clearpage}

Estos ciclos que buscamos no son mas que las componentes fuertemente conexas del digrafo. Si reducimos al digrafo de modo de que 
colapsamos a los nodos que pertenecen a una componente fuertemente conexa a un único nodo (como muestra la figura: ~\ref{fig:reduccion}), actualizando la información de los 
partidos arreglados, lo que obtenemos es un nuevo digrafo que cumple ser libre de ciclos (ver demostraci'on 3).

Entonces una vez que tenemos un digrafo libre de ciclos, podemos aplicar la propiedad que enunciamos antes, y resolver el problema en $O(n)$.


\subsection{Obtención de las componentes fuertemente conexas}
Para poder eliminar los ciclos, buscamos las componentes fuertemente conexas. Para hacerlo utilizamos el algoritmo de Kosaraju. 
El mismo logra encontrarlas en O(n+m). El algoritmo es básicamente DFS.

Funciona de la siguiente manera:
\begin{itemize}
\item Primero realiza un DFS numerando los nodos según el orden de finalización de las llamadas recursivas. (se repite hasta numerar todos los nodos).

\item Luego se arma el digrafo $g'$ que contiene los mismos nodos que g pero a$\leadsto$b en $g'$ si y solo si b$\leadsto$a en g. $g'$ tiene como caracter'istica que posee las mismas componentes conexas que g. Ademas si existe un camino entre dos vertices u y v en g, vale que existe un camino entre u y v en $g'$ si y solo si estan en la misma componente fuertemente conexa.

\item Una vez armado $g'$, se realiza un DFS en 'el, partiendo del nodo con mayor numeraci'on. Al terminar se obtiene una componente fuertemente conexa. 

\item El proceso se repite para todos los nodos no visitados, siempre en orden decreciente de numeraci'on.

\end{itemize}
Como lo que hace el algoritmo es DFS dos veces, tiene orden O(n+m)

Por ejemplo, apliquemos el algoritmo al digrafo de la figura ~\ref{fig:kosaraju1}:

\begin{figure}[H]
\centering
\subfigure[Comenzamos con el digrafo original]{
\includegraphics[scale=0.5]{./figuras/ej1/kosaraju1.png} }\hspace{0.5in} 
\subfigure[Realizamos DFS partiendo desde el 1 y numeramos los nodos seg'un el orden de la llamada recursiva]{
\includegraphics[scale=0.5]{./figuras/ej1/kosaraju2.png}}\hspace{0.5in} 
\subfigure[Como el 7 quedo sin marcar, realizamos una segunda DFS partiendo desde el]{
\includegraphics[scale=0.5]{./figuras/ej1/kosaraju3.png}}\hspace{0.5in} 
\subfigure[Una vez que marcamos todos los nodos, invertimos el digrafo]{
\includegraphics[scale=0.5]{./figuras/ej1/kosaraju4.png}} \hspace{0.5in} 
\subfigure[Como el 7 es el elemento de ma-yor numeraci'on comenzamos por él. Hacemos DFS, y todos los nodos que tocamos, son una componente fuertemente conexa]{
\includegraphics[scale=0.5]{./figuras/ej1/kosaraju5.png} }\hspace{0.5in} 
\subfigure[Ahora seguimos con el 1, el de mayor numeraci'on sin visitar. Luego de hacer DFS tenemos otra componente fuertemente conexa de G. Como no quedan mas nodos por visitar, terminamos]{
\includegraphics[scale=0.5]{./figuras/ej1/kosaraju6.png}}
\caption{Algoritmo de Kosaraju}
\setcounter{subfigure}{0}
\label{fig:kosaraju1}
\end{figure}

\subsection{¿Por que el algoritmo logra obtener las componentes fuertemente conexas?}
\label{funciona}
Primero numeramos a los nodos por el orden de finalizaci'on de la llamada recursiva al DFS. De esta manera, si tenemos que un nodo de una componente fuertemente conexa (llam'emoslo a) esta relacionado con otro elemento que no pertenece a la misma (llam'emoslo b), vale que si a$\leadsto$b entonces el número de a es mayor que el de b, pues si empiezo por a o por algunos de los nodos que llegan a el, voy a visitar a b, y reci'en cuando numere a b (y a todos los dem'as nodos c tal que a$\leadsto$c) , voy a numerar a a. Esto vale porque est'an en distintas componentes, si estuvieran en la misma depende de por cual nodo empiece. Si en cambio, val'ia que b$\leadsto$a el n'umero de a es menor que el de b, ya que si empezamos por a no llegamos a b, dado que no est'an en la misma componente; y si partimos de b, entonces vamos a numerar primero al nodo a y después a b.

Una vez que damos vuelta el digrafo, hacemos DFS partiendo desde el nodo de mayor numeraci'on no visitado, y solamente visitamos a los nodos de su componente. Esto se debe a que si en el digrafo original a$\leadsto$b, donde b no pertenece a la misma componente fuertemente conexa, sabemos que el número de b es menor que el de a, y que en el digrafo dado vuelta b$\leadsto$a, por lo cual  no llegamos a b. Si en cambio val'ia que b$\leadsto$a, el n'umero de b es mayor que el de a, y por lo tanto ya habr'iamos visitado a b.

Veamos el siguiente ejemplo donde b$\leadsto$a:
\begin{figure}[H]
\centering
\subfigure[Comenzamos con el digrafo original, a esta en una componente conexa, b en otra y b$\leadsto$a]{
\includegraphics[scale=0.6]{./figuras/ej1/aeshijo.png} }\hspace{1in} 
\subfigure[Numeramos los nodos, y como b$\leadsto$a el numero de b es mayor]{
\includegraphics[scale=0.6]{./figuras/ej1/aeshijoNumerado.png}}\hspace{1in} 
\subfigure[Cuando invertimos el digrafo, b es el nodo por donde vamos a empezar, y no hay camino que lleve de b hacia a, cuando sea el turno de partir de a, a b ya lo visitamos antes por lo que no se tiene en cuenta]{
\includegraphics[scale=0.6]{./figuras/ej1/aeshijoInverso.png}}
\label{fig:aeshijo}
\setcounter{subfigure}{0}
\end{figure}

Ahora consideremos un caso donde a$\leadsto$b
\begin{figure}[H]
\centering
\subfigure[Comenzamos con el digrafo original, a esta en una componente conexa, b en otra y a$\leadsto$b]{
\includegraphics[scale=0.6]{./figuras/ej1/aespadre.png} }\hspace{0.5in} 
\subfigure[Numeramos los nodos, y como a$\leadsto$b el n'umero de b es menor]{
\includegraphics[scale=0.6]{./figuras/ej1/aespadreNumerado.png}}\hspace{0.5in} 
\subfigure[Cuando invertimos el digrafo, a es el nodo por donde vamos a empezar, y no hay camino que lleve de a hacia b. Cuando salgamos de b, ya pasamos por a, por lo que se lo ignora]{
\includegraphics[scale=0.6]{./figuras/ej1/aespadreInverso.png}}
\label{fig:aespadre}
\setcounter{subfigure}{0}
\end{figure}


\subsection{Armado del digrafo reducido y resolución del problema}
Una vez que ya tenemos las componentes fuertemente conexas, armar el digrafo reducido es simple. 
\begin{itemize}
\item Primero guardamos en que componente quedo cada jugador

\item Luego tomamos las relaciones entre los jugadores, y las traducimos al nuevo digrafo: las 
relaciones dentro de la misma componente se descartan, y dos componentes est'an relacionadas si existe un jugador en cada una, 
tal que est'en relacionados. Es de notar que es necesario filtrar las relaciones intracomponente para no obtener un 
pseudografo que no nos permite usar la propiedad de los digrafos sin ciclos, pues un nodo queda relacionado con si mismo, por lo 
que tiene grado de entrada mayor  a 0. Tambi'en es de notar que no podemos obtener un multigrafo, ya que el digrafo es libre de 
ciclos: si vale que a$\leadsto$b y b$\leadsto$a, a y b deber'ian ser una 'unica componente fuertemente conexa.

\item Con esta información podemos armar el nuevo digrafo reducido, como el de la figura \ref{fig:reduccion}

\item Contamos cuantos elementos tienen grado de llegada 0, si solo hay uno ese gano. Entonces ganan todos los elementos de la componente. Como podr'ian no estar en orden, las ordenamos mediante bucket sort en $O(n)$

\end{itemize}

\subsection{ Nuevo algoritmo a partir de un mejor uso de la información}
Hasta ahora el algoritmo que tenemos es el siguiente:
\begin{enumerate}
\item Si m $<$ n - 1 decimos que no se puede armar el torneo.

\item Realizamos dfs para numerar los nodos hasta asignarel un valor a cada uno

\item Construimos un digrafo inverso

\item En este digrafo, realizamos dfs, partiendo de los nodos con valor mas alto, para obtener las componentes fuertemente conexas.

\item Usando dichas componentes, armamos un digrafo reducido (libre de ciclos).

\item Si hay un solo nodo (en el reducido) con grado de entrada 0, devolvemos los nod que forman dicha componente, sino no hay ganador.

\end{enumerate}

Si bien el algoritmo planteado anteriormente nos satisfacía, al punto de que casi lo implementamos como solución definitiva, ya que lograba el orden pedido, notamos que no est'abamos aprovechando toda la información que nos brindaba el algoritmo que obtiene las componentes fuertemente conexas: El nodo que tiene mayor numero luego del primer DFS (después del paso 2) es un potencial ganador. Potencial ganador significa que esta en una componente fuertemente conexa con grado de entrada 0. El abuso de expresión se refiere a que no hay ning'un nodo fuera de su componente fuertemente conexa que le gane a el o a otro de dicha componente. 

Es decir que en el digrafo reducido, el nodo correspondiente a dicha componente tendrá grado de entrada 0. Esto lo vemos porque como mostramos antes (ver \ref{funciona}), si hay un nodo fuera de su componente conexa que le gane a él o a alguno de la misma, este tendría un número asignado m'as alto.

De esta manera, al numerar los nodos sabemos que si hay ganadores, es decir jugadores para los cuales se puede arreglar el torneo, en nodo de mayor número estar'a si o si entre ellos. Podr'ia ocurrir que sea el de mayor número pero que su componente conexa no sea la única con grado de entada nulo (es decir en el digrafo reducido hay mas de un nodo con grado de entrada cero) en cuyo caso no hay ningún ganador.

Veamos los siguientes ejemplos:
\begin{figure}[H]
\centering
\subfigure[]{
\includegraphics[scale=0.6]{./figuras/ej1/Caso1.png} }\hspace{0.5in} 
\subfigure[]{
\includegraphics[scale=0.6]{./figuras/ej1/Caso2.png}}\hspace{0.5in} 
\subfigure[]{
\includegraphics[scale=0.6]{./figuras/ej1/Caso3.png}}
\label{fig:aespadre}
\caption{Resultado de númerar los nodos mediante DFS}
\setcounter{subfigure}{0}
\end{figure}

Consideremos ahora sus digrafos reducidos:
\begin{figure}[H]
\centering
\subfigure[]{
\includegraphics[scale=0.6]{./figuras/ej1/Caso1Reducido.png} }\hspace{0.5in} 
\subfigure[]{
\includegraphics[scale=0.6]{./figuras/ej1/Caso2Reducido.png}}\hspace{0.5in} 
\subfigure[]{
\includegraphics[scale=0.6]{./figuras/ej1/Caso3Reducido.png}}
\label{fig:aespadre}
\caption{Digrafos reducidos}
\setcounter{subfigure}{0}
\end{figure}

Notemos que siempre el nodo que quedo con mayor numeración (pintado de verde) esta en una componente conexa a la que no llega ningun nodo de afuera. Luego, una vez que armamos el digrafo reducido, se observa que el nodo donde quedo el jugador de mayor numeración (el correspondiente a su componente) posee grado de entrada 0. En los dos primeros digrafos, no se puede arreglar el torneo, mientras que en tercero si.

¿Podemos entonces usando esta información mejorar el algoritmo anterior?

La respuesta es afirmativa: 
\begin{enumerate}

\item Podemos hacer DFS primero para numerar los nodos (en verdad alcanza con saber quien tiene el valor mas alto).

\item Luego verificar que el de mayor numeración llegue a todos (para filtrar los casos donde hay mas de una componente conexa con grado 0).

\item Si es asi usamos la otra idea del algoritmo de Kosaraju para obtener su componente conexa: el digrafo inverso. Como no buscamos todas, sino la que contiene al nodo de mayor numeración lo que podemos hacer es un DFS desde este nodo pero usando las aristas que llegan a él, en vez de las que salen de él (notar que es equivalente a dar vuelta las flechas y hacer DFS común). De esta manera nos ahorramos tener que armar el digrafo inverso, el digrafo reducido y luego verificar los grados de entrada de cada nodo.

\item Si no se podía llegar a todos desde el nodo de mayor numeración, podemos decir que nadie gana.

\end{enumerate}

Este nuevo algoritmo, es el que decidmos implementar.

\subsection{Demostraciones auxiliares}
\newtheorem{teorema 1}{Teorema}
\begin{teorema 1}
\normalsize
Sea g=(V,X) tal que $\exists$! v1 $\in$ V tal que $d_{in}(v1)=0$, y G es libre de ciclos. Entonces $\forall$ $v_i$ $\in$ V, $v_i$ $\neq$ $v_1$, $\exists$ C, camino dirigido entre $v_1$ y $v_i$
\end{teorema 1}
\begin{proof}
\normalsize
Sea C1 el camino dirigido de longitud m'axima que llega hasta $v_i$.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/ej1/demostracion1.png}
\end{figure} 
Supongamos que no existe un camino entre $v_1$ y $v_i$, entonces sea $v_k$ el nodo donde comienza dicho camino. Como $v_k$ $\neq$ $v_1$ entonces $d_{in}(v_k) \neq 0$, luego existe $v_n$ tal que $v_n \leadsto v_k$. $v_n$ no puede estar en el camino C1, porque sino existe un ciclo, y por hip'otesis esto es falso. Consideremos entonces el camino C2 = ($v_n$,$v_k$)$\cup$C1 (donde $\cup$ es un abuso de notacion, seria agrego el par ($v_n$,$v_k$) al camino C1). Ahora C2 tiene longitud mayor que la de C1, entocnes tenemos un absurdo, ya que C1 era el camino de longitud m'axima.  
\end{proof}

\begin{teorema 1}
\normalsize
Sea g=(V,X) tal que $\forall$ v $\in$ V, $d_{in}(v)$ $>$ 0 $\rightarrow$ existe un ciclo en g
\end{teorema 1}

\renewcommand*{\proofname}{Demostración}

\begin{proof}
\normalsize
Sea g=(V,X) tal que  $\forall$ v $\in$ V, d(v) $>$ 0, consideremos el camino m'aximo de g, $v_1,v_2,...v_i,...,v_n$
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/ej1/demostracion.png}
\end{figure} 
Pero como $d_{in}(v)$ $>$ 0, existe $v_k$ tal que $v_k$ $\leadsto$ $v_1$. Si $v_k$ pertenece al camino, tenemos un ciclo, que era lo que quer'iamos demostrar.
Supongamos que no pertenece al camino. Entonces tengo un camino nuevo, que va de $v_k$ a $v_n$, que tiene mayor longitud que
el camino de $v_1$ a $v_n$, absurdo, puesto que $v_1,v_2,...v_i,...,v_n$ era el camino máximo.
\end{proof}
\vspace{0.2in}

\begin{teorema 1}
\normalsize
Sea g un digrafo reducido, es decir que cada nodo es una componente fuertemente conexa, entonces no existen circuitos en g
\end{teorema 1}
\begin{proof}
\normalsize
Supongamos que existe un circuito en g. Sean $a_1$,$a_2$,..., $a_i$,..., $a_n$ nodos, tal que el circuito pasa por ellos. Como tengo un circuito vale que para cada par de nodos $a_i$, $a_j$, existe un camino. Entonces $a_1$, $a_2$, ..., $a_n$ forman una componente fuertemente conexa. Absurdo, que provino de suponer que exist'ia un circuito en g.
\end{proof}

\section{Pseudocodigo}
\input{pseudo1}

Esta funcion debe llamarse con el contador inicializado en cero
y todos los visitados en false. Cada vez que termina, si no se visitaron todos
debe ser llamada de nuevo, manteniendo el contador y los visitados.

Los otros algoritmos que hacen dsf no se detallan en esta sección ya que el pseudocodigo de los mismos es muy similar
al anterior.
El algoritmo que realiza dfs para ver a cuantos llego, es muy similar a este ultimo
solo que no se numeran nodos, sino que se cuenta a cuantos toco desde el nodo donde empiezo
De forma similar el algoritmo que realiza dfs en reverso, hace los mismo pero en vez de numerar
guarda cada nodo que visita en una lista, y en vez de usar los otros nodos tal que nodo $\leadsto$otro nodo
se mueve hacia los otros nodos tal que otor nodo $\leadsto$nodo 

\section{Cuestiones de implementación}
Para resolver los problemas representamos los digrafos mediante listas de adyacencias. De esta manera podemos crearlos en O(n + m) donde n es la cantidad de nodos y m es la cantidad de v'ertices. Si bien el costo de saber si a $\leadsto$ b es mayor que usando una matriz de adyacencia, como no lo usamos para la resolución del problema no es algo que nos afecte. En cambio si usamos DFS en varias ocasiones y para esta función si nos es conveniente usar listas de adyacencia.

La estructura que usamos utiliza dos arreglos de listas, en la posición i de uno guarda los elementos que inciden en el nodo i, y en el otro guarda la lista de los elementos sobre los que i incide. Si bien tenemos informaci'on redundante, nos permite conocer facilmente los nodos que inciden sobre otro nodo dado, y de esta manera podemos obtener r'apidamente la componente fuertemente conexa de uno de los nodos ganadores.

Con respecto a las listas utilizamos las listas provistas por la stl de c++.

La clase digrafo, entonces, permite conocer en O(1) la cantidad de nodos, tambien con ese orden brinda los elementos que inciden sobre un nodo, y aquellos sobre los que el nodo incide.

\section{Cálculo de complejidad}
Para estudiar la complejidad del algoritmo consideramos que es apropiado considerar el modelo uniforme, ya que lo que importa en este caso es la cantidad de jugadores y partidos arreglados, mas que el coste que podr'ian tener las operaciones aritm'eticas.
Por eso realizaremos el an'alisis en funci'on de la cantidad de jugadores (n) y la cantidad de partidos arreglados (m).

Antes que nada creamos el digrafo, como usamos listas de adyacencia, hacer esto nos cuesta O(n+m): primero armamos dos arreglos de n posiciones, en cada uno vamos a tener una lista. Luego por cada par (a,b) insertamos a b en la lista de salida de a y hacemos lo propio con a en la lista de entrada de b.
 
Dado que, como dijimos anteriormente, si la cantidad de partidos arreglados es menor que $n-1$ sabemos que el torneo no puede arreglarse, por lo cual el algoritmo funciona en $O(1)$, ya que solo se pregunta por la cantidad de partidos arreglados y se termina el algoritmo.

Veamos que ocurre en los casos en los que m $\geq$ $n-1$. 

Lo primero que hacemos es un DFS (línea 4) que nos permite numerar los nodos según el orden de finalización de la llamada recursiva(En realidad al único que se le asigna número es al que tiene el mayor valor). Como un DFS que asigna un valor n'umerico a un nodo, su orden es O(n + m).

Una vez que hacemos esto, realizamos otro DFS desde el nodo de mayor numeraci'on (línea 5), para ver a cuantos nodos se puede llegar. Nuevamente, como en el caso anterior, por ser un DFS el orden es O(n + m).

En el caso en que no llegue a todos los nodos, terminamos devolviendo vac'io. Es decir que la complejidad en este caso es la de los dos DFS anteriores O(n + m).

En cambio, si llegaban todos, tenemos que hacer un nuevo DFS usando los ejes de entrada en vez de los de salida (línea 8). Como son los mismos ejes; pero con sentido inverso, la cantidad de ejes es la misma que antes: m. Cada nodo que visitamos lo agregamos a una lista en O(1). Por lo tanto como se trata de una variante del DFS que no realiza operaciones con costo extra, el orden es nuevamente O(n+m).

Esta lista es la que finalmente devolvemos, luego de ordenarla mediante bucketSort (línea 10) en orden O(n), ya que por enunciado la salida debe estar ordenanda de menor a mayor.

En el caso de que el digrafo sea completo, sabemos que m = $\frac{n*(n-1)}{2}$ por lo cual, en este caso O(n+m) $\subset$ O($n^2$).

Si bien el algoritmo no tiene un peor caso a priori, podemos notar que si no hay ganador no hacemos el tercer dfs, ni tampoco hacemos el bucketSort, por lo cual si bien a nivel de orde la situación es la misma, uno esperar'ia que esos casos se resuelvan mas r'apidamente.

Con respecto al tamaño de la entrada, si consideramos que ni n ni m estan acotados, podemos considerar que el tamaño de la entrada es el siguiente:
$$t = \lfloor log_2(n) \rfloor + 1 + \lfloor log_2(m) \rfloor + 1 + \sum_{i=1}^{m}{\lfloor log_2(v_i(0)) \rfloor + 1 + \lfloor log_2(v_i(1)) \rfloor + 1}$$ 
donde $v_i$ es el iesimo par de dos jugadores para los que se puede arreglar el partido.

Puesto que n y m no estan acotados y son valores que recibimos en el input, tenemos que considerar que su tamaño es logaritmico; luego recibimos los m partidos arreglados, y los jugadores que conforman esos partidos son del orden de n, por lo que su tamaño tambi'en es logaritmico.

Busquemos alguna cota inferior para t:
	$$t = \lfloor log_2(n) \rfloor + 1 + \lfloor log_2(m) \rfloor + 1 + \sum_{i=1}^{m}{(\lfloor log_2(v_i(0)) \rfloor + 1 + \lfloor log_2(v_i(1)) \rfloor + 1)}$$
	Entonces:
	$$t \geq \lfloor log_2(n) \rfloor + \lfloor log_2(m) \rfloor  + m$$

Veamos entonces que complejidad obtenemos en función del tamaño de la entrada. Para el caso donde m $<$ n - 1, sabemos que lo resolvemos en O(1), no obstante la entrada tiene que ser leida por lo que es mas apropiado considerar que es O(t). Ahora para el caso donde m $\geq$ n - 1, podemos considerar que:

Si m = n - 1:

	$$t \geq \lfloor log_2(n) \rfloor + \lfloor log_2(m) \rfloor  + n - 1$$
	
	Luego n $\leq$ t, entonces $m < n \leq t$. Entonces n + m $\leq$ t + t, por lo tanto, O(n + m) $\subset$ O(t)
	
Si m $\geq$ n:
	
	$$n \leq m \leq t$$
	
	Luego, al igual que en el caso anterior, n + m $\leq$ t + t, entonces nuevamente O(n + m) $\subset$ en O(t), es decir que a lo sumo tenemos una complejidad lineal en función del tamaño de la entrada.

%Al empezar buscamos obtener las componentes fuermente conexas mediante el algoritmo de kosaraju (algoritmo \ref{alg:algoritmo2}). Para eso, lo primero que hacemos es hacer una dfs para numerar a los nodos como se explico anteriormente. Dado que hacemos un dfs, tocamos a cada nodo una vez, y recorremos todos los vertices. Por esta razon tenemos un costo de $O(n+m)$.
%
%A continuación creamos el grafo invertido (algoritmo \ref{alg:algoritmo3}). Como tenemos la informacion de las relaciones en listas de adyacencia, la construccion del mismo, nos cuesta nuevamente $O(n+m)$.
%
%Cuando ya tenemos al grafo invertido, realizamos nuevamente una DFS para armar las componentes fuertemente conexas, nuevamente como es una DFS solo tocamos una vez a cada nodo y recorremos todos los vertices, tenemos un orden $O(n+m)$. En cada llamada el costo de ir guardando las componentes es constante, ya que solo se agrega un elemento al principio de una lista.
%
%Una vez que tenemos las componentes, lo que hacemos es guardar en que componente quedo cada nodo (línea 6,\ref{alg:algoritmo1}) . Para esto recorremos cada una de las componentes fuertemente conexas y miramos a cada nodo. Como la cantidad total de nodos que tenemos es n, justamente el costo de hacer esto es $O(n)$.
%
%Ahora buscamos la informacion sobre la relación entre las componentes fuertemente conexas (línea 6,\ref{alg:algoritmo1}). Lo que hacemos es pararnos en cada nodo, ver a quien le gana, y si le gana a alguien que no esta en su misma componente, guardamos la tupla en una lista (O(1)). Miramos cada nodo, y para cada uno miramos a quien le gana. Es decir que miramos cada partido arreglado una vez, y como miramos a cada nodo también una vez, tenemos una complejidad $O(n+m)$.
%
%Con esta informaci'on creamos el grafo reducido. En el peor caso, hay tantos nodos como habia antes e igual cantidad de aristas, por lo cual la cracion del mismo es $O(n+m)$.
%
%A continuaci'on buscamos cuantos nodos hay que tengan grado de entrada 0. Saber el grado de entra cuesta $O(1)$ ya que es preguntar por la longitud de la lista de adyacencia de entrada. Como tenemos que mirar a todos los nodos, el costo total es $O(n)$.
%
%Si nadie gana devolvemos una lista vacia en $O(1)$. En cambio si existe algun ganador, conocemos que componente es la que gana. Entonces tenemos que devolver a los nodos que pertenecen a ella. Como los tenemos que devolver en orden creciente, dado que sabemos que en el peor de los casos hay n ganadores, hacemos un bucket sort que tiene como costo $O(n)$
%
%Luego como en cada paso las operaciones que realizamos tienen un costo $O(n+m)$, podemos afirmar que el algoritmo tiene un costo de $O(n + m)$
%
%Si bien el algoritmo no tiene un peor caso claro, lo que si se puede notar es que en el caso en que existe un ganador, vamos a recorrer todas las componentes conexas para asegurarnos de eso, las mismas podrian llegar a ser n. Ahora bien, en cambio si no hay ganador, ni bien encontremos a dos con grado de entrada cero podemos parar porque sabemos que nadie gana. Si bien en el peor caso, para determinar que nadie gana necesitamos ver todas las componentes conexas, se podria esperar que en caso promedio, no haga falta revisar todas para encontrar dos con grado de entrada cero, por lo cual el algoritmo terminaria mas rapido (mas aun si consideramos que no tenemos el overhead del bucketsort)

\section{An'alisis experimental}
\subsection{Experiencias realizadas}
Para realizar las experiencias generamos digrafos aleatorios variando las variables cantidad de jugadores y cantidad de partidos arreglados. Para contar operaciones, declaramos una variable global, y la incrementamos por cada operación que realizamos, considerando que la asignaci'on de n posiciones de memoria cuenta como n operaciones.

Creamos digrafos, que cumplieran las pautas del enunciado y realizamos con ellos las siguientes experiencias:

La primer experiencia consistió en medir la cantidad de operaciones en función de ambas variables para ver su influencia conjunta en el comportamiento del algoritmo. Entonces tomamos un rango de n y para cada n generamos digrafos aleatorios con cada m entre 1 y el mínimo entre 400 y $\frac{(n-1)*n}{2}$ (se limito el m porque la generación de los casos de test tomaba un tiempo demasiado largo y ocupaba grandes cantidades de espacio en memoria).)

Luego decidimos dejar fija cada una ellas para observar el comportamiento por separado. La generación de digrafos fue similar a la de la experiencia anterior, se fijo una variable y la otra se movió libremente, elegidiendo los pares ordenados uniformemente.

Realizamos otra experiencia variando ambas variables, pero manteniendo constante la relación entre ellas, en particular consideramos m = $\frac{(n-1)*n}{2}$, es decir, generando digrafos completos. Quer'iamos observar como se comporta el algoritmo en digrafos que poseen la cantidad m'axima de aristas. en las que vale que m $subset$ O($n^2$)

Luego generamos instancias donde para todos los jugadores se puede armar el torneo y otras donde para ninguno puede arreglarse y comparamos la cantidad de operaciones de ambas, la idea es notar si efectivamente cuando no hay ganadores se observe que el algoritmo termina mas r'apidamente.

%Por otro lado, hicimos las siguientes experiencias con respecto al tamaño de entrada:

%Primero generamos grafos aleatorios, con n y m libres, calculamos el tamaño de cada instancias mediante la formula:
%$$ t = f(n,m) = \lfloor log_2(n) \rfloor + 1 + \lfloor log_2(m) \rfloor + 1 + \sum_{i=1}^{m}{\lfloor log_2(v_i(0)) \rfloor + 1 + \lfloor log_2(v_i(1)) \rfloor + 1}$$ 
%La idea era observar el comportamiento del algoritmo no en función de n y m sino además del tamaño de la entrada. 
%
%Posteriormente decidimos generar instancias similares a las de la experiencia 5, pero midiendo la cantidad de operaciones en funcion del tamaño de la entrada.

Los resultados obtenidos se encuentran a continuación.

\subsection{Resultados}
\subsubsection{Experiencia 1: Cantidad de operaciones, un función de n y m}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej1/experiencia1.png} 
\label{fig:exp1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{./figuras/graficos/ej1/experiencia1b.png} 
\label{fig:exp1b}
\end{figure}

\subsubsection{Experiencia 2: Cantidad de operaciones en función de n, con m fijo}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej1/experiencia2.png} 
\label{fig:exp2}
\end{figure}

\subsubsection{Experiencia 3: Cantidad de operaciones en función de m, con n fijo}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej1/experiencia3.png} 
\label{fig:exp3}
\end{figure}

\subsubsection{Experiencia 4: Cantidad de operaciones en función de n, con $m=\frac{(n-1)*n}{2}$ }
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej1/experiencia4.png} 
\label{fig:exp4}
\end{figure}

\subsubsection{Experiencia 5: Cantidad de operaciones en instancias con ganadores y sin ganadores}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./figuras/graficos/ej1/todosYNadie.png} 
\label{fig:exp5}
\end{figure}

%\subsubsection{Experiencia 6: Cantidad de operaciones en instancias con ganadores y sin ganadores}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.5]{./figuras/graficos/ej1/tamEntrada.png} 
%\label{fig:exp6}
%\end{figure}
%
%\subsubsection{Experiencia 7: Cantidad de operaciones en instancias con ganadores y sin ganadores}
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.5]{./figuras/graficos/ej1/todosYNadieT.png} 
%\label{fig:exp7}
%\end{figure}

\subsection{Discusi'on}
En la primer experiencia observamos que el gráfico esta compuesto por dos planos, el primero muestra aquellos casos donde $m < n - 1$ y que se descartan r'apidamente, en O(1). En cambio el otro representa aquellos casos donde m $\geq$ n - 1 y por lo tanto hay que realizar todo el proceso para determinar si hay un ganador o no. Que sea un plano se condice con el calculo de complejidad realizado ya que esta nos hab'ia dado O(n + m).

La segunda experiencia nos permiti'o notar que el comportamiento es lineal en la cantidad de jugadores. Sin embargo si dejamos fija la cantidad de partidos, y aumentamos la cantidad de jugadores, hay un momento a partir del cual vale que $m < n - 1$ y podemos resolver el problema en O(1), esto se manifiesta en la ca'ida de la cantidad de operaciones a partir de n $>$ 501.

La tercer experiencia nos permitió ver como se mantenía la tendencia lineal en función del m. En el grafico observamos 2 rectas, la primera corresponde a los casos $m < n -1$ y la segunda es para los casos donde no se puede decidir a priori y tenemos que hacer todo el proceso de los datos.

En la cuarta grafica notamos que en digrafos completos, la cantidad de operaciones crece cuadraticamente con respecto al n. Nosotros esper'abamos que eso ocurra, ya que esta forma parab'olica se explica en que como tomamos $m=\frac{(n-1)*n}{2}$ resulta que m es $\Theta(n^2)$, entonces O(n + m) es O($n^2$).

Finalmente, la experiencia 5 nos permitió reforzar la idea de que si no hay ganadores el algoritmo termina mucho mas r'apido que en aquellos casos donde si hay ganadores, lo cual hab'iamos predicho.

%En la experiencia 6 vemos como si bien la cantidad de operaciones puede acotarse con una recta, existen ciertas alteraciones sobre todo en la primer parte del grafico. Esto, creemos, se puede explicar en que para un mismo tamaño de entrada hay casos dispares donde puede haber ganadadores o no, y que como nos muestra la experiencia 7, la cantidad de operaciones varia entre estos casos; además, entre los t mas bajos estan aquellos en los que m < n - 1, los cuales se resuelven en O(1), y se observan en la parte inferior izquierda del grafico. Los t mas altos corresponden a los casos donde el grafo es completo, y por lo tanto el tamaño de entrada es el máximo para un m dado. 
%
%Finalmente la experiencia 7, nos permite ver como la tendencia vista en la experiencia 5 vuelve a mostrarse. Vemos, la cantidad de operaciones puede acotarse por una recta en t. Esto se condice con lo que esperabamos, ya que el orden que habiamos calculado era O(t).

A modo de conclusión, podemos decir que las experiencias nos permitieron corroborar el an'alisis te'orico que realizamos previamente.
