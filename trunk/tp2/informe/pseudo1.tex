\begin{algorithm}[H]
\caption{Devuelve la lista de aquellos jugadores, tal que se puede arreglar el torneo}
\label{alg:algoritmo1}
\begin{algorithmic}[1]
\PARAMS {Grafo con jugadores como nodos, y partidos arreglados como aristas direccionadas}
\IF{hay menos partidos arreglados que jugadores \textcolor{orange}{$-$} 1}
	\RETURN \textcolor{orange}{[ ]}
\ENDIF
\STATE DFS numerando todos los nodos por fin de llamada recursiva
\STATE hacer DFS solo para el nodo de mayor numeración
\STATE aCuantosLlega $\textcolor{orange}{\leftarrow}$ cantidad de nodos tocados en el DFS anterior
\IF{aCuantosLlega $\textcolor{orange}{==}$ todos los nodos del grafo}
	\STATE hacer DFS desde el nodo pero con las aristas de salida
	\STATE ganadores $\textcolor{orange}{\leftarrow}$ todos los nodos tocados por el dfs anterior
	\STATE ordenar(ganadores) \COMMENT{ lo hago con bucketSort porque los ganadores estan entre 1 y cantidad de nodos}
\ELSE
	\RETURN \textcolor{orange}{[ ]}
\ENDIF
\end{algorithmic}
\end{algorithm}
	
\begin{algorithm}[H]
\caption{numera nodos, guarda quien el que tiene el valor mas alto (cantidad de nodos -1)}
\label{alg:algoritmo1b}
\begin{algorithmic}[1]
\PARAMS{un grafo, un nodo del grafo, un contador que se modifica, un marcador de nodos visitados}
\PARAMS{una variable que se modifica y guarda el nodo de max valor}
\FOR{cada nodoAdyacente tal que nodo $\leadsto$ nodoAdyacente}
	\IF{ no lo visite}
		\STATE dfs(grafo,nodoAdyacente,contador,visitados,masValioso)
	\ENDIF
\ENDFOR
\IF{a este nodo le toca el valor mas alto}
	\STATE valioso $\textcolor{orange}{\leftarrow}$ nodo
\ENDIF
\STATE incrementar el contador
\end{algorithmic}
\end{algorithm}

