\chapter{Algoritmo exacto}
\section{Desarrollo}
Un dibujo incremental válido consiste en una permutación de los nodos 
de cada partición que mantenga el orden relativo de los nodos previamente 
fijados. Dados $v_i$ nodos originales en la partición i, se agregan $IV_i$ 
nodos en cada partición. La cantidad posible de soluciones es:
$$IV_1!*\dbinom{IV_1 + v_1}{v_1}*(IV_2!*\dbinom{IV_2 + v_2}{v_2})$$
Esto se debe a que la partición 1 tiene $IV_1 + v_1$ nodos, y por lo 
tanto hay esa cantidad de posiciones. De esas, $v_1$ estarán destinadas a los
nodos existentes, cuyo orden relativo es fijo. Una vez que elegimos sus posiciones, 
el orden entre ellos es fijo. En las $IV_1$ posiciones restantes podemos poner 
cualquier permutación de los nodos nuevos. Luego la cantidad de órdenes válidos
para la partición 1 es: 
$$ IV_1!*\dbinom{IV_1 + v_1}{v_1} $$
Luego, para cada uno de estos órdenes válidos en la partición 1, tenemos (análogamente)
una cantidad equivalente para la partición 2:
$$IV_2!*\dbinom{IV_2 + v_2}{v_2}$$ permutaciones en la segunda partición.
El total de combinaciones es finalmente el producto de las combinaciones de cada
partición, que resulta en la fórmula presentada anteriormente.

Dada la naturaleza exponencial del problema a resolver, decidimos utilizar la técnica de
\textit{backtracking} para formular un algoritmo exacto. Comenzamos por desarrollar un algoritmo
de fuerza bruta que simplemente explora el árbol de combinaciones que va generando progresivamente,
y luego lo fuimos refinando agregando optimizaciones y podas.

El algoritmo de backtracking aprovecha la naturaleza recursiva del problema de dibujo incremental,
agregando progresivamente cada nodo móvil en todas sus posiciones válidas y produciendo así
un nuevo conjunto de nodos fijos que se incrementará con una llamada recursiva. Dado un candidato
inicial con una cantidad de cruces dada, esta situación nos permite realizar una poda sencilla
del árbol de combinaciones. Ocurre que inevitablemente todo dibujo incremental del grafo parte
de un dibujo original cuya cantidad de cruces acota inferiormente la del dibujo incrementado.
Por lo tanto, al construir un candidato para una llamada recursiva, si la cantidad de cruces
en su parte fija supera a la del mejor candidato hallado hasta el momento, no tiene sentido descender
por la rama y puede podarse sin perder soluciones.

Con esta idea, resulta útil proveerse rápidamente de un candidato inicial cuya cantidad de cruces
sea baja, ya que \textit{a priori} permitirá descartar mayor cantidad de ramas por pasarse de su
valor. Con este fin, tiene sentido utilizar alguna solución heurística de las desarrolladas en este
trabajo.

El pseudocódigo del algoritmo resultante es aproximadamente:
\begin{algorithm}[H]
\caption{Halla la solución exacta al problema de dibujo bipartito incremental}
\begin{algorithmic}[1]
\PARAMS{fijo1, fijo2, movil1, movil2, adyacencias}
\STATE construir un candidato abritrario y 
\IF{fijo1 = $\emptyset$ y fijo2 = $\emptyset$}
    \IF{el dibujo obtenido tiene menos cruces que el mejor candidato}
        \STATE reemplazar el mejor candidato por este dibujo
    \ENDIF
\ELSIF{fijo1 $\neq$ $\emptyset$}
    \STATE tomar el primer elemento de movil1
    \FOR{cada posición del elemento en fijo1}
        \STATE poner el elemento en esa posición
        \IF{el dibujo obtenido no tiene más cruces que el mejor candidato}
            \STATE llamar recursivamente
        \ENDIF
        \STATE sacar el elemento de esa posición
    \ENDFOR
\ELSIF{fijo2 $\neq$ $\emptyset$}
    \STATE tomar el primer elemento de movil2
    \FOR{cada posición del elemento en fijo2}
        \STATE poner el elemento en esa posición
        \IF{el dibujo obtenido no tiene más cruces que el mejor candidato}
            \STATE llamar recursivamente
        \ENDIF
        \STATE sacar el elemento de esa posición
    \ENDFOR
\ENDIF
\RETURN el mejor candidato hallado
\end{algorithmic}
\end{algorithm}

De esta manera, el árbol de \textit{backtracking} que tenemos es:
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.9]{./figuras/exacto/arbolbt.png}
\caption{Árbol de \textit{backtracking}}
\end{figure}

El algoritmo lo recorre en orden DFS, cortando aquellas ramas que pueden ser descartadas
inmediatamente sin visitarlas.

\subsection{Implementación eficiente}

Dado que el algoritmo recursivo se ejecutará una vez por cada nodo del árbol de combinaciones,
es importante que su ejecución sea lo más eficiente posible para disminuir el tiempo total
de ejecución.

La primera versión del algoritmo era similar a la de fuerza bruta: recorría el árbol de combinaciones,
y cuando obtenía una permutación completa, construía el dibujo y contaba enteramente sus cruces.
A continuación agregamos la poda simple descripta anteriormente. Sin embargo, resultaba claro
que recalcular los cruces de todo el dibujo para cada hoja del árbol de permutaciones no era
eficiente ya que gran parte de los cálculos eran redundantes entre hojas vecinas del árbol, puesto
que compartían gran parte de las posiciones de los nodos en el dibujo.

Utilizando los métodos descriptos anteriormente, decidimos efectuar los cálculos mediante
una técnica incremental. Constatamos que la iteración que en el pseudocódigo corresponde
a agregar un nodo móvil en todas las posiciones posibles dentro del dibujo fijo de su partición
puede describirse en términos de 3 operaciones: agregar el nodo al final del dibujo, 
permutarlo $n$ veces hacia atrás con su vecino inmediato, y finalmente extraerlo del principio 
del dibujo donde habrá quedado ubicado. Con este procedimiento, un nodo móvil dado
pasa por todas las posiciones posibles dentro del dibujo fijo original.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.25]{./figuras/exacto/swaps.png}
\caption{Permutaciones mediante swaps}
\end{figure}

Dado un candidato, la cantidad de cruces que se agregan por agregarle un nuevo nodo al 
final a una partición puede ser calculada mucho más rápidamente que los cruces de todo 
el dibujo. Además, como se vio anteriormente, calcular la cantidad de cruces que resulta
de un \textit{swap} también es eficiente. Esta mejora se incluye en el algoritmo evitando
así recalcular todos los cruces para cada permutación, y en cambio llevando una cuenta temporal
de cruces que se modifica continuamente para reflejar los cruces del candidato que se está
evaluando.

\subsection{Tabulado de resultados}

Aún tras incluir los cálculos incrementales como se describió en el último párrafo, se puede
aprovechar de forma más eficiente aún la realización de ciertos cálculos.
Consideremos un dibujo con dos permutaciones $V = <v_1,v_2,...,v_n>$, $W = <w_1,w_2,...,w_k>$.
La cantidad de cruces puede obtenerse como:
$$Cruces(V,W) = \sum_{i=1}^{k-1}{\sum_{j=i+1}^{k}{crucesEntre(w_i,w_j,V)}}$$

Esto es, dada una permutación de V, los cruces de todo el dibujo, para cualquier
permutación de W, dependen únicamente de los valores de $crucesEntre(w_i, w_j, V)$, función
que calcula los cruces entre dos nodos $w_i$ y $w_j$ para la permutación de V elegida y
suponiendo que $w_i$ está antes de $w_j$ en el dibujo. Esto puede hacerse ya que la cantidad
de cruces que se producen entre los ejes de 2 nodos de una partición depende únicamente de su
orden relativo y de las posiciones dentro de la partición restante.

Por lo tanto, una vez que construimos una permutación de una de las 2 particiones (parte superior
del árbol en el gráfico explicativo del árbol de \textit{backtracking}), podemos tabular los $k^2$
valores de  $crucesEntre()$ necesarios para el cálculo de los cruces de cualquier permutación de
la otra partición: todo el subárbol que pende de una permutación completa de la partición 1 comparte
los mismos valores de $crucesEntre()$. Teniendo esta tabla, el cálculo de cruces del dibujo completo
puede realizarse mediante la suma de los mismos según la fórmula de arriba, lo cual podría agilizar
el conteo de cruces. Cabe destacarse que el llenado de esta tabla tiene un costo no despreciable,
y por tanto es importante realizar pruebas para determinar si las ventajas de realizar este tabulado
no son superadas por el costo de la creación de la tabla. 

Como se verá más adelante, las pruebas mostraron que el uso de esta tabulación mejora significativamente
el rendimiento del algoritmo. En función de esta mejora, podemos observar que los cálculos realizados
con ayuda de la tabla son mucho más rápidos que los que se realizan sin ella. Por lo tanto decidimos
incluir una segunda mejora que consiste en decidir cual de las 2 particiones tiene más permutaciones
posibles, y asignar ésta a la parte inferior del árbol cuya exploración está más optimizada gracias al
uso de la tabla. Antes de esta decisión, se tomaba de forma arbitraria que lo recibido como
``partición 1'' se ubicaba en la parte superior del árbol, puesto que la situación era simétrica y solo
influía el tamaño total del árbol.

Si bien no es posible realizar la misma tabulación para la partición asignada a la parte
superior del árbol (puesto que no disponemos de la ubicación de los nodos en la otra partición
aún), es posible realizar una optimización parcial: si bien no conocemos las posiciones
de \textit{todos} los nodos en la partición vecina, si conocemos la posición de aquellos
que son fijos y por tanto no modifican su orden relativo. Se puede construir una tabla más
pequeña para, nuevamente, agilizar el conteo de cruces en las permutaciones de la
partición de la parte superior.

\subsection{Podas}

Disponiendo de la tabla de cruces entre pares de nodos, pudimos construir una función de poda
más efectiva, mediante una cota inferior más fina para la cantidad mínima de ejes que produce
una rama. Nuevamente, para una permutación dada de $V$, tenemos que:

$$Cruces(V,W) \geq \sum_{i=1}^{k-1}{\sum_{j=i+1}^{k}{min(crucesEntre(w_i,w_j,V),crucesEntre(w_j,w_i,V))}}$$

Como tenemos estos valores tabulados, resulta muy sencillo calcular esta cota y podar en función
del valor obtenido. Esto utiliza el hecho de que dados dos nodos $w_i$, $w_j$ de la partición 2, 
una vez que se los coloque en el dibujo, agregarán una cierta cantidad de cruces (ya sea $crucesEntre(w_i, w_j)$
o $crucesEntre(w_j, w_i)$ dependiendo de su orden relativo). Como disponemos de estos dos valores,
podemos usar el mínimo entre ambos como una cota inferior de los cruces producidos por la dupla
$w_i$, $w_j$ dada la permutación de $V$ tomada.

Una vez que tenemos esta cota inferior, podemos descartar de antemano a aquellas ramas donde el
valor de dicha cota supere la cantidad de cruces del mejor candidato obtenido hasta el momento.
Una vez más, este cálculo redunda en un costo adicional que podría ser contraproducente
en caso de que la poda no lograra eliminar una cantidad significativa de ramas. Nuevamente, es
necesario realizar pruebas para determinar su efectividad. Las mediciones observaron que este
mecanismo de poda es particularmente bueno y elimina partes sustanciales del árbol de permutaciones
sin un costo excesivo (producto, en gran parte, de la disponibilidad de la tabla de cruces
descripta previamente, que aligera mucho el cómputo de la cota).


\section{Pseudocódigo}
\begin{algorithm}[H]
\caption{Resuelve de forma exacta el problema de dibujo incremental de grafos bipartitos}
\begin{algorithmic}[1]
\STATE inicializarParametros
\STATE mejorSolución $\leftarrow$ construir una solución con la heuristica constructiva
\STATE buscarMejorSolucion()
\RETURN mejorSolucion
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Inicializa variables que va a usar el algoritmo exacto}
\begin{algorithmic}[1]
\STATE determinar cual de las particiones tiene menos permutaciones, llamarla 1, a la otra llamarla 2
\STATE construir indice de posiciones para los nodos que ya estan en el dibujo
\STATE constuir listas de adyacencias para los nodos de 1 y los fijos de 2
\STATE calcular los cruces del dibujo original
\STATE construir la tabla para la particion 1
\IF{no hay moviles en la particion 2}
\STATE construir la tabla para la particion 2
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{construye todas las particiones que pueden ser solucion buscando la mejor (o una de ellas)}
\begin{algorithmic}[1]
\IF{ no hay mas moviles por poner}
\IF{los cruces de la solucin que arme son menos que los de la mejor hasta ahora}
\STATE mejorSolucion $\leftarrow$ solucionActual
\ENDIF
\ELSIF{no hay mas moviles que poner en la particion 1}
\STATE agregar atras al primer movil a la particion (sacarlo de moviles y actualizar indice)
\STATE cruces $\leftarrow$ curces + los cruces que me agrega el nuevo nodo
\WHILE{ el nuevo no recorrio toda la particion}
\IF{cruces + minimoCruces < los cruces del mejor}
\STATE buscarMejorSolucion()
\ENDIF
\STATE intercambiar al nuevo por el nodo que esta adelante de el (actualizar posiciones y cruces)
\ENDWHILE
\STATE sacar al nodo \COMMENT{quedo adelante de todo}
\STATE actualizar posiciones y cruces
\ELSE
\STATE agregar atras al primer movil a la particion (sacarlo de moviles y actualizar indice)
\STATE cruces $\leftarrow$ curces + los cruces que me agrega el nuevo nodo
\WHILE{ el nuevo no recorrio toda la particion}
\IF{cruces + minimoCruces < los cruces del mejor}
\IF{ no quedan mas nodos moviles en esta particion}
\STATE construir tabla para la partición 2
\ENDIF
\STATE buscarMejorSolucion()
\ENDIF
\STATE intercambiar al nuevo por el nodo que esta adelante de el (actualizar posiciones y cruces)
\ENDWHILE
\STATE sacar al nodo \COMMENT{quedo adelante de todo}
\STATE actualizar posiciones y cruces
\ENDIF
\end{algorithmic}
\end{algorithm}

Construir tabla 1 toma todos los nodos de la particion 1 de a pares  (i,j) y guarda en una matriz en la posicion (i,j) los cruces entre los nodos ubicados con i antes que j y en (j,i) los cruces entre ellos ubicados al reves. Para contar los cruces, solo se tiene en cuenta a los fijos de la particion 2.

Construir tabla 2 es analogo, pero tiene en cuenta a todos los nodos de la particion 1 para contar los cruces.

minimo cruces utiliza las tablas (la correspondiente a la particion que se esta llenando) y realiza la cuenta antes descripta para obtener una cota inferior a la cantidad de cruces que se pueden originar

\section{Detalles de implementación}
% uso de listas doblemente enlazadas para push_back(), pop_front() y swap() en O(1)

% uso de buffers únicos para fijo1, fijo2, movil1, movil2 y cruces que son usados
% por todas las instancias recursivas del algoritmo (ahorra mucho espacio en stack y evita
% muchas copias de listas o conjuntos de nodos fijos y moviles).

% uso de diccionarios sobre arreglo para mayor velocidad (el uso de memoria del
% algoritmo está básicamente determinado por el tamaño del stack, por lo tanto
% no tiene sentido optimizar el uso de memoria de los factores constantes)

% uso de la heurística constructiva para determinar el candidato inicial

% uso de profiling para determinar los puntos a mejorar del algoritmo

\section{Cálculo de complejidad}
Antes de correr nuestro algoritmo exacto, lo que hacemos es limpiar el grafo, lo cual nos da un costo inicial $O(V_1+V_2+m)$ donde $V_i$ es la cantidad de nodos de partición i sin filtrar y m la cantidad de ejes.

Al iniciar lo que hacemos es inicializar ciertas variables que nos serán de utilidad tales como las listas de adyacencia parciales, vectores con posiciones, etc. Todo esto tiene un costo $O(v_1+v_2 + m)$ donde $v_i$ es la cantidad de nodos de una partición. Esto lo podemos acotar por  $O(v_max + m*log(v_max))$. En esta inicialización se llena la tabla de resultados para la primer partición. Lo que calculamos es $crucesEntre(w_i,w_j) \forall w_i,w_j \in v_1$. Esto tiene un costo $O(v_{1}*v_{max})$, ya que son $O(v_{1})$ calculos y cada calculo tiene cosot $O(v_{max})$.
  %TODO: completar
Para realizar el estudio de este algoritmo creemos que será provechoso considerar por separado el llenado de cada partición. Como comentamos antes, primero se llena una de las particiones, y después se llena la otra. Ademas consideraremos para el estudio el caso donde no es posible podar nada.

Primero observemos el costo que tenemos al pasar por cada nodo del arbol de permutaciones de la primer partición. En cada paso lo que hacemos es insertar un elemento al final, y contar cuantos cruces nos agrega, lo cual lo hacemos en $O(v_1+ m )$. Esto último no es cierto, pues en verdad no se inserta para cada nodo del árbol, sino que dado un nivel, el elemento se inserta tantas veces como nodos hay en nivel anterior del arbol y luego se hace swap, sin embargo para no hacer mas engorroso aun el calculo, decidimos simplificarlo de esa manera. Luego intentamos aplicar la poda. Aplicarla tiene un costo $O(v_{1}^2)$ ya que tengo que obtener la suma de los minimos de los cruces entre dos elementos y dichos elementos ya estan en la tabla. Después hacemos otra llamada para ir armando el siguiente nivel. Una vez que regresamos de esa llamada, hacemos un swap del nodo con un adyacente, y actualizamos los cruces, esta actualización la hacemos en $O(1)$ ya que tenemos los cruces entre ambos tabulados. Una vz que el elemnto recorre toda la partición hay que sacarlo, lo cual también tiene un costo $O(v_1+ m )$ porque se actualizan los cruces.

Entonces recorrer el árbol de llenado de la primer partición tiene un costo:

$$O(nodos * (v_{1}^2 +(v_1+m)))$$

aqui nodos es la cantidad de nodos del arbol de permutación. Veamos cuantos nodos tiene:
Podemos obtener la cantidad de nodos del arbol en función de la cantidad de nodos moviles y fijos que tiene, de la siguiente manera:
%TODO: gonza explica esta formula
  \begin{equation}
     tamArbol(moviles,fijos) = \left\{
	       \begin{array}{ll}
		 1      & \mathrm{si\ } moviles = 0 \\
		(fijos+1)*tamArbol(moviles-1,fijos+1) + 1 & \mathrm{si\ } moviles \neq 0 \\
	       \end{array}
	     \right.
   \end{equation}

Esta formula no es facilmente manejable, por lo cual usaremos una cota. Dado que cada nivel tiene mas nodos que el nivel anterior (si tengo una permutación de k elementos, al agregar un nuevo elemento obtenemos k + 1 posibles ordenes), podemos acotar la cantidad de nodos del arbol como:
 $$h*moviles_1!*\dbinom{moviles_1 + fijos_1}{fijos_1}$$

Donde h es la altura del arbol y $moviles_1!*\dbinom{moviles_1 + fijos_1}{fijos_1}$ es la cantidad de hojas.

La altura del árbol es igual a la cantidad de nodos moviles en la partición 1, ya que en cada nivel estamos agregando un nodo, mas 1 por la raiz donde no agregamos nada todavia. Luego:

cantidad de nodos $\leq (moviles_1+1)*moviles_1!*\dbinom{moviles_1 + fijos_1}{fijos_1}$

Luego el orden de completar todas las permutaciones de la primer partición nos quedó:

$$O(moviles_1*moviles_1!*\dbinom{moviles_1 + fijos_1}{fijos_1}(v_1+m+v_{1}^2))$$

En cada hoja del arbol de las permutaciones de la primer partición, completamos la tabla para la segunda partición. Esto tiene un orden $O(v_2*v_{max})$

Completar la segunda partición tiene el mismo costo que completar la primer partición, con la salvedad de que en las hojas tenemos un costo $O(v_1+v_2)$ por copiar al mejor dibujo (el grafo no se copia, se usa una referencia).

Entonces, completar el arbol de la segunda particion tiene un costo:
$$O((moviles_2+1)*moviles_2!*\dbinom{moviles_2 + fijos_2}{fijos_2}(v_2+m+v_{2}^2) + (v_1+v_2)*moviles_2!*\dbinom{moviles_2 + fijos_2}{fijos_2}(v_2+m+v_{2}^2))$$

Para cada hoja del arbol de la primer partición, llenamos todo un árbol de la segunda. Por lo tanto el costo final es (luego de sacar algunos factores comunes):

%$ O(moviles_1*moviles_1!*\dbinom{moviles_1 + v_1}{v_1}(v_1+m+v_{1}^2) + moviles_1!*\dbinom{moviles_1 + v_1}{v_1}(v_1+m+v_{1}^2) *(moviles_2*moviles_2!*\dbinom{moviles_2 + fijos_2}{fijos_2}(v_2+m+v_{2}^2) + (v_1+v_2)*moviles_2!*\dbinom{moviles_2 + fijos_2}{fijos_2}(v_2+m+v_{2}^2))+\dbinom{moviles_1 + v_1}{v_1}(v_1+m+v_{1}^2)*v_2*v_{max}+ m*log(v_max))$

$O(moviles_1!*moviles_1!*\dbinom{moviles_1 + fijos_1}{fijos_1}(v_1+m+v_{1}^2)*(moviles_1+ moviles_2!*\dbinom{moviles_2 + fijos_2}{fijos_2}(v_2+m+v_{2}^2)*(moviles_2 + (v_1+v_2)) + v_2*v_{max}) + V_1 + V_2 + m*log(v_max))$ 

Usando que $moviles_1!*\dbinom{moviles_1 + fijos_1}{fijos_1} = \frac{(moviles_1 + fijos_1)!}{fijos_1!}$ 

$O(\frac{(moviles_1 + fijos_1)!}{fijos_1!}(v_1+m+v_{1}^2)*(moviles_1+ \frac{(moviles_1 + fijos_2)!}{fijos_2!}(v_2+m+v_{2}^2)*(moviles_2 + (v_1+v_2)) + v_2*v_{max}) + V_1 + V_2 + m*log(v_max))$ 

De la formula vemos que es preferible tomar como primer partición a aquella que tenga una menor cantidad de hojas, de esta manera la segunda tabla se construye menos veces y se aprovechan mas calculos.

\section{Análisis experimental}

\subsection{Experiencias realizadas}
% utilidad de invertir particion1 y particion2
% aptitud de las podas: poda "simple" vs. poda loca
% utilidad de las tablas: algoritmo con y sin tabulado
% tiempos para un grafo con cantidad de permutaciones dadas y densidad de ejes variable
% tiempos del algoritmo de backtracking vs. tabla vs. tabla + poda loca (en funcion de las combinaciones)

\subsection{Resultados}

%aclarar que los de C++ se hicieron con -g y que con -O3 va 3x más rápido

\begin{figure}[H]                                                                                     
\centering
\includegraphics[height=11cm]{./graficos/exacto/tiempos_tabulado.png} 
\caption{Tiempos con y sin tabulado de valores}
\end{figure} 

\begin{figure}[H]                                                                                     
\centering
\includegraphics[height=11cm]{./graficos/exacto/tiempos_inversion} 
\caption{Tiempos con y sin inversión de particiones}
\end{figure} 

\begin{figure}[H]                                                                                     
\centering
\includegraphics[height=11cm]{./graficos/exacto/podas.png} 
\caption{Comparación de podas}
\end{figure} 

\begin{figure}[H]                                                                                     
\centering
\includegraphics[height=11cm]{./graficos/exacto/tiempos_densidad.png} 
\caption{Tiempos en función de la densidad del grafo}
\end{figure} 

\begin{figure}[H]                                                                                     
\centering
\includegraphics[height=11cm]{./graficos/exacto/tiempos_cpp.png} 
\caption{Tiempos en función del tamaño del árbol de \textit{backtracking}}
\end{figure} 


\section{Discusión}
% estimación del tiempo del algoritmo para resolver un caso dado (en función de la cantidad de combianciones)
