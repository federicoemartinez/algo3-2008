Ejercicio 1:
Enunciado

Desarrollo:
	 La primer idea para resolver el ejercicio fue obtener los primos menores que el número a factorizar (en adelante n) y luego obtener la potencia con la que cada uno lo divide, quedándonos con el de mayor potencia o con el mayor de todos los de máxima potencia. Sin embargo esta solución era costosa, en la medida que necesitaba primeo obtener todos los números primos menores que n.
	 Un segundo acercamiento nos permitió salvar esta dificultad, de manera que no fue necesario obtener los primos menores a n explícitamente. El proceso consite en partir de 2, probar si 2,3,5 dividen a n y a partir de aquí ciclar generando numeros de la forma 6*k + 1 o 6*k + 5 con k >= 1 (se puede probar que si un numero es primo mayor que 5 tiene esa forma. Ver Demostracion 1). Cuando obtenemos que alguno lo divide seguimos dividiendo hasta obtener la potencia y si es mayor que la maxima hasta el momento se actualiza. Cada vez que dividimos a n, nos quedamos con el cociente como nuevo n. Un problema de este metodo es que se hacen divisiones por números que no son primos, pero el costo es menor que el de buscarlos o de decidir antes de dividir si el candidato es primo. Es importante notar que si un numero no es primo, no lo puede dividir (ver demostracion 2). Si no pudieramos asegurar esto, el algoritmo fallaria, por ejemplo al factorizar 2*3*5 guardaria a 15 como maximo factor primo, lo cual claramente es erroneo. 
	Finalmente, utilizamos un teorema que nos dice que si un numero es compuesto existe por lo menos un primo menor que su raiz que lo divide(ver demostracion3), de esta manera iteramos solo hasta la raiz del numero (la cual se actualiza luego de terminada la division por un primo) en vez de hasta n.


Demostraciones:
Teorema 1:
	Sea p en Z, primo , p > 5, entonces existe k >= 1 / p=6*k+1 o p = 6*k +5.
Demostracion:
Supongamos que no, entonces p = 6*k+j con j en {0,2,3,4}
si j = 0
p = 6* k, luego 6 | p abs! 
si j = 2
p = 6*k +2, pero 2 | 6*k y 2 | 2 luego 2 | p abs!
si j = 3
p = 6*k + 3, pero 3 | 6*k y 3 | 3 luego 3 | p abs!
si j = 4
p = 6*k +2, pero 2 | 6*k y 2 | 4 luego 2 | p abs!
ergo
p=6*k+1 o p = 6*k +5

Teorema 2:
	sea k numero compuesto, y sea n / para todo p primo p < k (n:p) = 1, entonces k no| n
Demostracion
	Dado que k es compuesto, existen q1...qj primos tal que k = q1*....*qj
	entonces supongamos que k | n,
          k|n <-> (q1*...*qj)|n como los qt son primos
          -> q1|n o q2|n ..... o qj|n pero q1...qj < k luego (n:qt) = 1
	abs!

Teorema
	k compuesto sii existe p primo / p <= sqrt(k) y p | k
	<- trivial
	-> k = p1*p2....*pn donde pi > int(sqrt(k))
		k = p1*p2....*pn >sqrt(k)^n = k*t


Ejercicio 3
	La primera idea para abordar este problema fue ordenar el arreglo y contar la cantidad de apariciones guardando el elemento con mas apariciones.  Una mejora a este procedimiento es notar que la moda en un arreglo con la caracteristica de los del problema, es decir que la moda esta mas de la mitad de las veces, coincide con el elemento n/2 (ver Demostracion). Entonces si ordenamos el arreglo, en vez de contar apariciones podemos solamente tomar el elemento n/2  para obtener la moda. Ambos algoritmos tienen un orden n * log n, por lo que nos gustaria poder bajar ese orden.
         Investigando sobre el tema encontramos el algoritmo de Loyd-Pratt-Rivest-Tarjan que permite encontrar la mediana de un arreglo en orden lineal, sin necesidad de ordenarlo. 
	La idea es usar un pivote para partir el arreglo y quedarnos solo con la parte donde puede estar la mediana. Es necesario para tener orden lineal poder encontrar un buen pivote en un orden a lo sumo lineal. El algoritmo resuelve esto partiendo el arreglo en arreglos de 5 elementos, tomando la mediana de estos y luego tomando la pseudomediana de estas “medianas”.  Se puede demostrar que este procedimiento permite encontrar la mediana en orden lineal. Esta solucion se descarto por varias razones: En primer lugar su implementación era bastante complicada. Por otro lado, la demostración del orden es compleja.
	Buscamos entonces otra forma de obtener un orden lineal aprovechando que la frecuencia de la moda era mayor a la mitad. La idea basicamente es recorrer el arreglo con dos indices. Si encontramos dos elementos iguales incrementamos uno de los indices (en adelante j) y dejamos al otro (en adelante i) en la posicion donde esta. Si encontramos 2 elementos diferentes, los tachamos (ponemos una marca en un arreglo de booleanos). Luego avanzamos  i hasta que llegue a una posicion sin tachar y hacemos lo propio con j hasta llegar a una posicion sin tachar pero que tambien sea mayor que i. El ciclo termin cuando j se pasa del largo del arreglo. Entonces devolvemos el indice donde quedo parado el indice i.
	En cada paso el algoritmo “tacha” dos elementos que no son la moda, o uno que es la moda y otro que no. Entonces solo terminan sobreviviendo algunos elementos de la moda. 
	Al terminar el ciclo, los elementos sin tachar desde i hasta el final del arreglo son iguales. Entonces podrian ser moda o elementos distintos a la moda. Esto ultimo no puede ocurrir ya que la frecuencia de la moda es como minimo n/2 + 1, entonces que ocurra  implicaria que tache por lo menos 2(n/2+1) > n
	Este algoritmo fue finalmente el que adoptamos como solucion ya que nos daba el orden lineal buscado y su implementacion era simple.

