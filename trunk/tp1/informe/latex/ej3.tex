\chapter{ejercicio 3}
\part{Ejercicio 3}
\section{Enunciado}
Dado un arreglo de $n$ elementos en el que hay un elemento que aparece m'as de la mitad de las veces, encontrar la moda, es decir, el valor que aparece m'as veces.

\section{Desarrollo}
La primera idea para abordar este problema fue la de ordenar el arreglo y contar la cantidad de apariciones guardando el elemento con mas apariciones. Esta primera idea no tuvo mucha aceptaci'on, ya que se observo, que el orden requerido para ordenar dicho arreglo, no cumplia con lo requerido para resolver este punto.
\paragraph{}
Una mejora a este procedimiento, fue la de notar que la moda en un arreglo con las caracteristicas brindadas por el problema, es decir que la 
moda se encuentra mas de la mitad de las veces, coincide con el elemento $n/2$. Por lo tanto si se ordena el arreglo, en vez de contar apariciones, basta con tomar el elemento $n/2$ para obtener la moda. Esta mejora tambien requiere que el arreglo se ordene, por lo tanto, como la idea anterior, quedan descartados ya que ambos algoritmos tienen un orden de complejidad $O(n*log n)$, lo que nos obliga a bajar dicho orden. Investigando sobre el tema se encontro el algoritmo de Loyd-Pratt-Rivest-Tarjan, que permite encontrar la mediana de un arreglo en orden lineal($O(n)$), sin necesidad de ordenarlo. El algoritmo se basa en el uso de un pivote para partir el arreglo y quedarse solo con la parte donde se puede encontrar la mediana. Es necesario para tener orden 
lineal poder encontrar un buen pivote en un orden a lo sumo lineal. El algoritmo resuelve esto partiendo el arreglo principal, en arreglos 
de 5 elementos, tomando la mediana de estos y luego tomando una pseudomediana de dicha ``mediana''. Se puede demostrar que este procedimiento permite encontrar la mediana en un orden lineal. Esta soluci'on se descarto ya que su implementaci'on era bastante complicada, lo cual no era conveniente teniendo en cuenta que luego, se realizar'ia un analisis de dicho algoritmo para definir su complejidad.
\paragraph{}
Se Busc'o entonces otra forma de  obtener un orden lineal aprovechando que la frecuencia de la moda era mayor a la mitad. La idea basicamente es recorrer el  arreglo con dos indices. Si se encuentran dos elementos iguales, se incrementa uno de los indices (en adelante $j$) y se deja inmovil al otro (en adelante $i$) en la posici'on donde se encuentra. Pero si se encuentran 2 elementos diferentes, estos son tachados (para esto se utiliza una marca sobre un arreglo de posiciones booleanas). Luego se avanza $i$ hasta que llegue a una posici'on sin tachar y se hace lo propio con $j$ hasta llegar a una posici'on sin tachar pero que tambien sea mayor que $i$. El ciclo termina cuando $j$ se excede del limite del arreglo. Entonces es devuelto el valor donde qued'o parado el 'indice $i$. En cada paso el algoritmo ``tacha'' dos elementos que no son la moda, o uno que es la moda y otro que no. De esta forma solo terminan sobreviviendo algunos elementos de la moda. Al terminar el ciclo, los elementos sin tachar desde i hasta el final del arreglo son iguales. Entonces podrian ser moda o elementos distintos a la moda. Esto ultimo no puede ocurrir ya que la frecuencia de la moda es como minimo $n/2+1$, entonces que ocurra implicar'ia que tache por lo menos $2*(n/2+1) > n$. Este algoritmo fue finalmente el que se adopt'o como soluci'on ya que nos garantizaba el orden lineal buscado y su implementaci'on era simple.

\section{Pseudocodigo}
\input{ejercicio3/seudocodigo/moda.tex}

%TODO calculo, demostracion, tamaño de entrada, porq uniforme, peor caso, mejor caso
\section{C'alculo de complejidad}

\section{Analisis Experimental}
\subsection{Experiencias realizadas}
Nuevamente para este algoritmo se decidi'o medir tanto la cantidad de operaciones como el tiempo, en funcion de la cantidad de 
elementos del arreglo, con la intencion de confirmar nuestro analisis te'orico. Para ello se generaron arreglos de largo creciente 
con elementos al azar (distribuci'on uniforme) respetando que la frecuencia de la moda sea de por lo menos $n/2+1$.\\
Por otro lado para observer la influencia de la frecuencia de la moda en el comportamiento del algoritmo se hicieron corridas de prueba
para un $n$ fijo aumentando la frecuencia y midiendo la cantidad de operaciones asi como el tiempo.\\
En algunos casos adem'as fue posible utilizando la tecnica de cuadrados m'inimos, dar una funci'on que aproxime el comportamiento obtenido experimentalmente. En dichos casos, la ecuacion de $f(x)$ se encuentra en el gr'afico.

\subsection{Gr'aficos}
%TODO: rehacer estos graficos es al pedo tener 10^-5 segundos, pasar a milisegundos por lo menos (opcional por ahora)
\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio3/benchmark/graficos/corridas_aleatorias_n_creciente/grafico.png}
\caption{Cantidad de operaciones en funcion del tama\~{n}o del arreglo}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio3/benchmark/graficos/frecuencia/frecuencia.png}
\caption{Cantidad de operaciones en funci'on de la frecuencia ($n$ = 500)}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio3/benchmark_de_tiempo/graficos/moda-1000-casos.png}
%TODO: rehacer este grafico es al pedo tener 10^-5 segundos, pasar a milisegundos por lo menos 
\caption{Tiempo (milisegundos) en funci'on del tama\~{n}o del arreglo}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio3/benchmark_de_tiempo/graficos/aumento-frecuencia.png}
\caption{Tiempo (milisegundos) en funci'on de la frecuencia ($n$ = 500)}
\end{figure}

\section{Discusi'on}
En los graficos de tiempo se observ'o que al aumentar el tama\~{n}o del arreglo, el tiempo aumenta de forma lineal. Lo mismo ocurre con la cantidad de operaciones. Esta situacion se corresoponde con el analisis te'orico que se realizo.
Por otro lado en los gr'aficos en funci'on de la frecuencia de la moda, el tiempo y las operaciones parecieran decrecer linealmente. Esto evidencia que el mejor caso se produce cuando todos los elementos del arreglo resultan ser la moda. Lo anteriormente dicho se explica de la siguiente manera: si todos los elementos son iguales a la moda, el if de la linea 5 del pseudocodigo, es siempre falso, por lo que el ciclo recorre el arreglo sin hacer otro tipo de operacion.
