\part{Ejercicio 2}
\section{Enunciado}
La empresa Musimundo cuenta con una serie de sucursales repartidas por el pa'is. Recientemente ha decidido cerrar su sucursal
de Iruya y llevarse toda la mercader'ia al dep'osito central. Debido al dif'icil acceso ha dispuesto s'olo un cami'on para
llevar toda la mercader'ia. Sin embargo, es posible que no todo el material pueda ser llevado en un s'olo viaje del cami'on
d'ebido a las restricciones de carga, por lo que la parte que no entre en el cami'on ser'a vendida a valores despreciables el
 d'ia del cierre.

Dada la capacidad de carga m'axima P del cami'on y una lista de los productos del local conteniendo el valor $v_i$ y peso $p_i$ 
de cada uno, encontrar la lista de productos de mayor valor que sea posible llevar en el cami'on sin que el peso total de la
lista supere la carga m'axima. El valor de una lista de productos se calcula como la suma de los valores de los productos
involucrados. En caso de haber varias listas con el mismo valor m'aximo, encuentre cualquiera de ellas.
Realice un algoritmo para resolver el problema usando la t'ecnica de backtracking.

\section{Desarrollo}
Dado que el problema deb'ia ser resuelto con backtracking, buscamos la forma de aplicar dicha t'ecnica 
algor'itmica para su resoluci'on. B'asicamente la idea es formar todos los subconjuntos de cosas para encontrar aquel que maximice el valor total, 
sin exceder la capacidad de carga del cami'on.

La restricci'on expl'icita es el conjunto de cosas a llevar y la restricci'on impl'icita es la capacidad de carga del cami'on. A 
medida que se va armando una soluci'on, son descartadas aquellas cuyo peso excede la capacidad del cami'on, y de 
esta manera se va podando el 'arbol de posibles soluciones.

De esta manera, se construye el siguiente 'arbol de recursion:
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./ejercicio2/arbol.png}
\end{figure}
En la ra'iz del 'arbol se tiene la soluci'on $\emptyset$. Luego, en cada nodo se tiene una $n-upla$ donde un $0$ en la posici'on $i$ 
indica que el elemento $i$ no es parte de esta soluci'on, mientras que  un $1$ indica que el elemento est'a inclu'ido en la soluci'on.
Las hojas de este 'arbol son las soluciones posibles. Como cada elemento puede estar o no estar, se tienen dos posibilidades para cada
uno (llevarlo o no). Esto implica que la cantidad posible de soluciones si se tienen $n$ elementos es $2^n$.

El algoritmo implementado toma como par'ametros el camion (cosas, cuantas cosas y capacidad)  y dos soluciones posibles (una en donde est'a guardada la mejor 
encontrada hasta el momento y otra que guarda la que se va construyendo). Adem'as se lleva un 'indice que 
indica sobre que objeto se est'a decidiendo si conveniente o no llevarlo.

B'asicamente una llamada a la funci'on consiste en verificar si se agrega o no a la soluci'on el elemento apuntado por $indice$. Si es as'i (es 
decir que al agregarlo, el peso total no excede el peso m'aximo), se agrega a la soluci'on candidata y se contin'ua con la 
siguiente llamada recursiva. 'Esta consiste en una llamada sin agregar el elemento apuntado por 'indice. Cuando se encuentra 
una soluci'on mejor a la actualmente 'optima, 'esta es reemplazada. Repitiendo este proceso se pueden observar todas 
las hojas del arbol, para quedarse con la mejor.

Ademas de la restricci'on propia del problema, buscamos definir otras que nos permitieran efectuar mejores podas. Asi una primera idea fue ordenar el arreglo en orden creciente de pesos. De esta forma, si durante la construccion de una solucion, llegamos a que el elemento k no se puede agregar, sabemos que ningun elemento entre $k+1$ y n se va a poder agregar, porque su peso es mayor que el de k, y por ende mayor que la capacidad disponible.

Otra idea que tuvimos consisti'o en preguntar cuando estoy construyendo una soluci'on si tiene sentido que siga bajando. Esto lo hacemos de la siguiente manera: si considero la suma de los valores de los elementos que me quedan por visitar y este valor sumado al del candidato actual no me da mejor que el de la mejor soluc'on hasta el momento, no tiene sentido que baje porque no voy a lograr una soluci'on con valor mayor. En un principio, para hacer esto se nos ocurri'o hacer la suma en cada llamada para ver si bajo. Sin embargo este calculo era costoso, por lo cual buscamos alguna alternativa mejor. La idea entonces fue antes de empezar a trabajar con el arreglo de cosas, sumar el valor de todos los elementos. Este n'umero es el m'aximo valor que puedo lograr con un conjunto de cosas. Cada vez que hago una llamada calculo si el valor de mi candidato actual mas el m'aximo me sirve para mejorar mi solucion. Por otro lado, cuando hago una llamada sin incluir a un elemento, resto al m'aximo posible el valor de dicho elemento.

Por ejemplo:

Si tengo un conjunto de cosas tal que sus valores son: {1,2,3,4}. El m'aximo valor que podr'ia llevar es 10. Cuando estoy armando una soluci'on que excluye al valor 1, el maximo es 9. Si ademas quito al 2, el maximo es 7, etc.
Consideramos que si bien estas podas no nos mejorar'an el orden de complejidad, si nos permitirian en general observar un mejor desempe\~{n}o.

Para implementar el algoritmo se definieron los tipos $Cosa$, $Camion$ y $SolucionPosible$ con la finalidad de aportar m'as claridad al mismo.

\section{Pseudoc'odigo}
\input{ejercicio2/seudocodigo/mochila.tex}

%TODO: completar esta demostracion, hablar de tamaño de entrada. Tarea de fede
%hablar de peor caso
\section{C'alculo de complejidad}
Para este ejercicio decidimos usar el modelo uniforme, ya que consideramos que lo que hace al n'ucleo del problema es la
cantidad de cosas a llevar. Por esa raz'on no nos parece desacertado considerar que el peso y el valor de las cosas estan 
acotados. Asimismo consideraremos que el tama\~{n}o de la entrada es la cantidad de cosas entre las cuales elegir.

Antes de llamar a la funcion que hace backtracking, lo que hace el algoritmo es ordenar el arreglo con merge sort (lo cual es O(n*log(n)) y luego suma todos los valores del arreglo, lo cual es O(n). Veremos a continuacion que como el orden de la funcion principal  mayor que estos, no hacen a la complejidad del algoritmo. 

Sea N la cantidad de cosas que hay para elegir. Observemos que dado un N, si llamamos n a la cantidad de elementos que me quedan por procesar (es decir por decidir que hacer con ellos) la
T(0) = N + 1, pues hay que preguntar si encontre una mejor soluci'on y hay que copiar la soluci'on actual. Si no me quedan mas elementos que mirar y tengo que copiar la nueva solucion, esta copia tiene como costo la cantidad de elementos entre los cuales elegir.
Entonces podemos decir que las ecuaciones de recurrencia son:
$$T(0) = N +1$$
$$T(n) = 2*T(n-1) + k$$
k viene de las operaciones que se realizan dentro de cada llamda, las cuales son todas O(1).

Proponemos que: $$T(n) = N*2^n + k*(2^n-1) + 2^n$$

veamoslo por inducci'on:
n = 0:\\
$$T(0) = N + 1 =  N*2^0 + k*(2^0-1) + 2^0$$
supongamos que vale para n, veamos que vale para n+1:
$$T(n+1) = 2T(n) + k$$
usando la hipotesis inductiva:
$$T(n+1) = 2(N*2^n + k*(2^n-1) + 2^n) + k$$ 
$$T(n+1) = N*2^{n+1} + k*(2^{n+1}-2) + 2^{n+1} + k$$
$$T(n+1) = N*2^{n+1} + k*(2^{n+1}-1) + 2^{n+1}$$
Que era lo que queriamos ver.
Ahora bien como $$T(n) = N*2^n + k*(2^n-1) + 2^n$$, y ademas sabemos que n es del orden de N, tenemos que T(n) $\in$ $O(N*2^N)$

Luego el algoritmo tiene un orden exponencial en funci'on del tama\~{n}o de la entrada, a'un pese a las podas; y esto es de esperarse ya que las podas funcionan en algunos casos, mientras que en otros no ayudan en nada. Otra forma de ver el orden, es considerar el funcionamiento de algoritmo. La idea es revisar cada soluci'on posible, y sabemos que estas son $2^n$. En el peor de los casos, tenemos que recorrerlas todas y ademas actualizar la mejor solucion cada vez. Como esto ultimo tiene O(n) lo que nos queda es $O(2^n*n)$.

Si el algoritmo solo desecha un camino cuando no puede agregar a un elemento porque se excede del peso, el peor caso se da cuando puede poner a todos los elementos, ya que llegara a cada hoja. 

Observando las podas que implementamos, uno esperaria que en general el algoritmo se comporte bien. Incluso en el caso antes mensionado. Ahora supongamos que tenemos un conjunto ${a_1,a_2,...a_n}$ donde el peso y el valor de $a_i = 1$ $\forall i \in {1...n-1}$ y el peso y valor de  
$a_n = n$ y que el peso del camion es n.

En este caso ninguna de nuestras podas van a funcionar, puesto que la poda por pesos baja siempre hasta el ante ultimo nivel, salvo en el caso donde no agregue a ningun $a_i$ con i $<$ n. Tampoco funciona ver cual es el m'aximo que puedo armar porque hasta que no llegue al caso donde solo pongo a $a_n$ el valor m'aximo que puedo armar siempre es mayor que n, pero las soluciones que arme siempre valen menos que n. De esta manera en este caso, se recorren practicamente todas las ramas. 

\subsection{Experiencias realizadas}
Para probar el comportamiento del algoritmo medimos tiempos y cantidad de operaciones en funcion del tama\~{n}o de la entrada, es decir de la cantidad de posibles elementos a llevar. A modo de ver si nuestras podas significaban una mejora en la practica contrastamos los resultados entre el algoritmo sin podas, y el algoritmo con podas. Para hacer las pruebas generamos casos donde la cantidad de elementos era creciente y la composicion de las cosas era aleatoria. El peso que el camion podia llevar se fijo en 200 y los valores y pesos de las cosas seguian una distribucion uniforme (0,100). Ademas se analizo el comportamiento del algoritmo en aquellas situaciones que consideramos como peores casos. En los gr'aficos, algoritmos sin poda es el que no ordena el arreglo, ni observa la suma potencial del camino.

\subsection{Gr'aficos}
%TODO: sergio hace los graficos con n creciente y aleatorio

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{../../codigo/ejercicio2/benchmark/graficos/comparacion_con_poda_sin_poda/caso_promedio/comparacionCantOpConPodaSinPoda.png}
\caption{Cantidad de operacione en funci'on de la cantidad de cosas (peso y valor aleatorios con distribuci'on uniforme)}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../../codigo/ejercicio2/benchmark/graficos/operaciones_peor_caso_poda/peorCasoConPoda.png}
\caption{Cantidad de operaciones en funci'on de la cantidad de elementos, peor caso para la poda}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../../codigo/ejercicio2/benchmark/graficos/operaciones_peor_caso_poda/peorCasoSinPoda.png}
\caption{Operaciones en funci'on de la cantidad de cosas, peor caso sin podas }
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../../codigo/ejercicio2/benchmark_tiempos/graficos/tiempo_caso_promedio/ComparacionPodavsSinPoda.png}
\caption{Tiempo en funci'on de la cantidad de cosas, casos aleatorios}
\end{figure}

\section{Discusi'on}
En los graficos pudimos observar el comportamiento exponencial del algoritmo. En las corridas de casos generales, se observo un mejor comportamiento del algoritmo que implementaba las diversas podas, lo cual es esperable, uno tenderia a creer que algunas ramas se van a podar si la configuracion de las cosas es al azar.

 Tambien el algoritmo con podas se comporto mucho mejor que el algoritmo sin podas en el peor caso de este, es decir cuando hay que llevar a todos los elementos; esto se explica en que en este caso la primer mejor soluci'on que se arma es la que 'optima, por eso no baja por ninguna otra rama, ya que ninguna tiene el potencial de superarla.
 
 En el peor caso de nuestro algoritmo con podas, si se observa que el comportamiento es peor que el del algoritmo com'un y esto se explica si tenemos en cuenta que en este caso no se hacen podas efectivas y sin embargo tenemos el overhead de ordenar el arreglo y hacer la traducci'on de los indices para poder guardarlo en el archivo de salida.
 
 El grafico de tiempos, muestra la misma tendencia que el de cantidad de operaciones.
 
 A modo de conclusi'on, podemos decir que se validaron las hip'otesis planteadas durante el an'alisis te'orico