\chapter{Heurísticas Constructivas}
\label{constructivas}


\section{Introducción}
Presentamos a continuación tres diferentes ideas de heurística constructiva
para el problema de dibujo de grafo bipartito. Comentaremos las ideas detrás
de cada una así como un ejemplo de su aplicación y el pseudocódigo correspondiente,
para luego examinar empíricamente su comportamiento a partir de prototipos
en Python. Con esta información, elegiremos la de mejor comportamiento 
para su implementación definitiva en C++, que será la que utilicemos
posteriormente en el algoritmo GRASP. Las heurísticas utilizan los métodos 
incrementales para conteo de cruces descriptos en \ref{reUso}.

En todos los casos se trata de heurísticas \textit{greedy} que parten del
dibujo a incrementar y agregan progresivamente los elementos nuevos (nodos,
ejes o ambos) en la posición que optimiza algún criterio \textit{greedy}.

\section{Descripción de las heurísticas}

\subsection{Heurística de inserción de nodos}

El primer enfoque que evaluamos consiste en partir del dibujo original (aquel
cuyos nodos están en un orden que no puede ser alterado) y se completa progresivamente
agregando los nodos nuevos en la posición óptima si se asume que el dibujo
previo estaba fijo. Esto reduce el problema de obtener las mejores posiciones para
cada nodo (en conjunto) a una sucesión de problemas en que hay que obtener
la mejor posición para insertar únicamente un nodo, lo cual es mucho más simple
desde un punto de vista de complejidad.

Esencialmente, se elige uno de los nodos móviles y se examina cuantos cruces genera
insertarlo en cada una de sus posiciones posibles. A continuación se toma la posición
que menos cruces produce y se lo inserta en ella, pasando el nodo a formar parte de los
nodos fijos hasta el momento, y recomenzando el procedimiento hasta que no queden
nodos por insertar.

La elección se hace alternativamente para una y otra partición (siempre que queden
nodos móviles por insertar en cada partición, se elige e inserta uno de cada una, en
lugar de insertar primero todos los que van a una partición, y a continuación los que
van a la otra).

En el caso en que en el grafo incremental aparezcan ejes nuevos entre nodos
que cuya posición ya estaba determinada, estos ejes se agregan de antemano al
grafo ya que agregan información sobre los cruces que se producirán al agregar
los demás nodos.

Resta eliminar la ambiguedad del orden en que se eligen los nodos móviles que se van a
insertar. Consideramos tres variantes:
\begin{enumerate}
\item Escogerlo al azar
\item Escoger el nodo que tenga más adyacencias ya colocadas
\item Escoger el nodo que tenga menos adyacencias ya colocadas
\end{enumerate}

Entendemos por cantidad de ``adyacencias ya colocadas'' a la cantidad de ejes
que unen a un nodo móvil  con nodos ya fijados del grafo (ya sea porque eran
parte del dibujo original, o porque su posición ya fue establecida previamente
por la heurística).


A modo de ejemplo, vamos a aplicar la heurística en sus distintas variantes
al siguiente grafo:

\begin{figure}[H]
    \centering
    \setcounter{subfigure}{0}
    \subfigure[]{
    \includegraphics[scale=0.25]{./figuras/constructivas/insercionGreedyRandom/dibujo0.png} }
    \label{fig:posta}
    \subfigure[]{
    \includegraphics[scale=0.25]{./figuras/constructivas/insercionGreedyRandom/posta.png}}
    \caption{Dibujo de partida y dibujo óptimo}       
\end{figure} 

A continuación mostramos la ejecución de la heurística. Los nodos marcados con
rojo son los que el algoritmo agrega en cada iteración.

\begin{itemize}

\item Inserción con selección aleatoria
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo2.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo4.png}}
\end{figure}

\item Inserción con selección por mayor grado

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo2.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo4.png}}
\end{figure}

\item Inserción con selección por menor grado
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo2.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo4.png}}
\end{figure}
\end{itemize}


\subsubsection{Pseudocódigo}

\begin{algorithm}[H]
\caption{Propone un dibujo mediante la inserción golosa de nodos}
\begin{algorithmic}[1]
\PARAMS{dibujo original a incrementar}
\STATE cruces $\leftarrow$ cruces del dibujo original
\WHILE{queden nodos por poner}
    \FOR{cada partición donde queden nodos móviles por colocar}
        \STATE nodo $\leftarrow$ elegir uno entre los nodos móviles
        \STATE sacar al nodo de entre los nodos a poner
        \STATE colocar al nodo en la ultima posición en su partición
        \STATE crucesNuevo $\leftarrow$ cruces + cruces que se producen al agregar el nodo atrás de la particion
        \STATE mejorCruces $\leftarrow$ crucesNuevo
        \STATE mejorPos = ultima posición
        \WHILE{no se revisaron todas las posiciones dentro de la partición}
            \STATE mover al nodo a la proxima posición \COMMENT{``swapear'' al nodo con el que está en la posición anterior}
            \STATE crucesPreSwap $\leftarrow$ cruces entre el nodo a insertar y el nodo anterior antes del \textit{swap}
            \STATE crucesPostSwap $\leftarrow$ cruces entre el nodo a insertar y el nodo anterior después del \textit{swap}
            \STATE cruces $\leftarrow$ cruces - crucesPreSwap + crucesPostSwap
            \IF{ cruces $<$ mejorCruces}
            	\STATE mejorCruces $\leftarrow$ cruces
            	\STATE mejorPos $\leftarrow$ la posición que estoy verificando
            \ENDIF
        \ENDWHILE
    	\STATE poner al nodo en mejorPos
        \STATE cruces $\leftarrow$ mejorCruces
    \ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm} 


\subsection{Heuristica de inserción de ejes}

Una vez más partimos del dibujo original, pero en este caso procedemos agregando ejes:
tomamos un eje ``nuevo'' y insertamos sus extremos en el par de posiciones válidas
que minimiza el total de cruces en el dibujo obtenido. Entendemos por eje ``nuevo'' a
aquellos ejes que tienen al menos uno de sus extremos no fijado de antemano. En el caso
en que uno de los extremos del eje pertenezca al dibujo original (su posición relativa
a los otros nodos de ese dibujo es fija), este nodo podría de todos modos tener más de una posición
válida en el dibujo incrementado y por lo tanto se prueban todas las posiciones que
mantienen el orden relativo original. 

En cada iteración, si uno de los nodos del eje
que se está insertando ya fue fijado por una pasada anterior del algoritmo, se lo
extrae e inserta nuevamente. Si bien podría parecer que el algoritmo repite
cálculos de forma redundante, esto no es necesariamente cierto puesto que se reinserta
un nodo cuya posición ya se había establecido, el nuevo dibujo contiene más ejes
que el que se había usado para tomar la decisión anterior, y por tanto la nueva
decisión será más ``informada'' que la primera desde un punto de vista heurístico
(lo cual no implica que sea mejor). Este tipo de decisión permite que la inserción
de un nuevo eje pueda incluso disminuir la cantidad de cruces respecto del dibujo
anterior, cosa que era imposible en la heurística anterior (donde el número de cruces
a lo sumo se mantiene igual en cada iteración, pero nunca mejora).

Por estas diferencias podríamos presuponer que esta heurística, al ser más
sofisticada que la anterior, podría obtener mejores resultados. Sin embargo,
el aumento de costo no es despreciable: para cada eje habrá que recorrer todos
los pares de posiciones posibles para sus dos extremos observando cuantos
ejes produce cada uno. Esto deberá ser tenido en cuenta cuando realicemos el
análisis experimental.

Si aplicamos la heurística para el grafo de \ref{fig:posta}, obtenemos lo siguiente:

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo2.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo4.png}}
\end{figure}

Notemos como en el último paso, al agregar el eje $(3,8)$ se mueve al nodo 8 de 
la posición que le había asignado antes, de modo de reducir la cantidad de cruces. 
Por otro lado observamos que si bien el algoritmo logró la solución óptima, esto se
debió a que cuando existía ambiguedad entre varias posiciones donde poner a los nodos
(debido a que todas ellas producían la misma cantidad de cruces), los puso abajo. Si 
hubiese elegido ponerlos arriba (opción válida, dado que genera la misma cantidad de 
cruces: 0) el resultado hubiera sido distinto.


\subsubsection{Pseudocódigo}
\begin{algorithm}[H]
\caption{Propone un dibujo mediante la inserción golosa de ejes}
\begin{algorithmic}[1]
\STATE ejesPuestos $\leftarrow$ los ejes del dibujo original
\STATE puesto$[v_i]$ $\leftarrow$ ¿$v_i$ estaba en el dibujo original?
\FOR{cada eje $(x,y)$ a agregar}
    \IF{ya puse a $x$}
       \STATE sacarlo
    \ELSE
       \STATE puesto$[x]$ = True
    \ENDIF
    \IF{ya puse a $y$}
       \STATE sacarlo
    \ELSE
       \STATE puesto$[y]$ = True
    \ENDIF
    \STATE agregar el eje a ejesPuestos 
    \STATE agregar $x$ a la lista de adyacencia de $y$
    \STATE agregar $y$ a la lista de adyacencia de $x$
    \STATE calcular los rangos en los cuales puedo mover $x$ y $y$ \COMMENT{si alguno estaba en el dibujo original, hay que respetar el orden relativo}
    \STATE insertar $x$ en su primer posición válida
    \STATE insertar $y$ en su primer posición válida
    \STATE mejoresCruces $\leftarrow$ los cruces por ponerlos en esta posición
    \STATE mejorPosición $\leftarrow$ posición actual
    \FOR{cada posición válida para $x$}
        \FOR{cada posición válida para $y$}
            \STATE contar los cruces por dejarlos en esa posición
            \IF{generan menos cruces que mejoresCruces}
               \STATE mejoresCruces $\leftarrow$ cruces por tenerlos en esta posición
               \STATE mejorPosicion $\leftarrow$ posición actual
            \ENDIF
            \STATE mover $y$ a su proxima posición
        \ENDFOR
        \STATE mover $x$ a su próxima posición válida
        \STATE mover $y$ a su primer posición válida
    \ENDFOR
    \STATE mover $x$ y a $y$ a la mejorPosicion
\ENDFOR
\end{algorithmic}
\end{algorithm} 


\subsection{Heurística de inserción de nodos por mediana}

La idea general de esta heurística es buscar que ningún nodo este demasiado 
``lejos'' de sus adyacentes. Como criterio heurístico para lograr esto,
utilizamos como posición de un nodo la mediana de las posiciones de sus
adyacentes.

El procedimiento es el siguiente: en un principio se comienza con solamente 
los nodos que ya estaban en el dibujo original acompañados de sus ejes.
Tomamos entonces al nodo de mayor grado (con respecto a los nodos que ya están
puestos, análogamente a la primera heurística), calculamos la mediana de las 
posiciones de sus adyacentes y una vez que la obtenemos, probamos insertar 
al nodo en la posición correspondiente a la mediana obtenida, o en las posiciones
inmediata anterior o posterior a ésta, eligiendo de las tres a la que genere menos
cruces en el dibujo. En el caso en que la mediana no sea un índice válido (porque 
una partición tiene menos nodos que la otra, y el valor de la mediana se calcula a 
partir de la posición de los nodos de la más grande, y por tanto la mediana podría
ser mayor que el tamaño de la partición más chica) la truncamos. Repetimos el 
procedimiento iterativamente hasta que están puestos todos los nodos.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.25]{./figuras/constructivas/medianaTruncada.png}
\caption{ejemplo de inserción por mediana con truncamiento}
\end{figure}

Al igual que en la heurística de inserción de nodos, si había ejes a agregar 
entre los nodos que ya estaban, estos se agregan al inicio del algoritmo para 
dar más información a las posteriores inserciones.

Si aplicamos la heurística a \ref{fig:posta} lo que se obtiene es, en este caso,
la misma secuencia que en la heurística de inserción \textit{greedy} de nodos. Esto
se debe a que siempre se agregan nodos que tienen un único adyacente, y éste está 
ubicado al final de la partición vecina.

Esta heurística utiliza un criterio \textit{greedy} que podríamos calificar de
indirecto: las otras heurísticas son \textit{greedy} en el sentido que minimizan
el número de cruces de cada inserción (minimizan localmente el mismo criterio que
debe minimizarse globalmente), mientras que la de la mediana utiliza como
criterio local la distancia a la que queda cada nodo de sus adyacentes. Es una 
heurística similar a la del baricentro, que en el caso del problema de dibujo de 
grafos bipartitos sin la característica de ser incrementales se comporta de forma
muy favorable. %TODO citar paper :p

Como mejora adicional, Luego de ubicar a todos los nodos, se hace una pasada 
en cada partición intercambiando nodos en posiciones consecutivas si esta permutación
disminuye el número total de cruces del dibujo. Esto se hace con el objetivo de paliar
los problemas originados por el truncamiento de los valores de las medianas descripto
anteriormente.


\subsubsection{Pseudocódigo}

\begin{algorithm}[H]
\caption{Propone un dibujo mediante inserción por la mediana de los adyacentes}
\begin{algorithmic}[1]
\WHILE{queden nodos sin poner}
    \STATE elegir un nodo de grado máximo con respecto a los que ya están puestos
    \STATE calcular la mediana de las posiciones de sus adyacentes
    \IF{mediana $>$ tamaño actual de la partición}
        \STATE mediana $\leftarrow$ tamaño de la partición
    \ENDIF
    \FOR{ cada i = mediana-1, mediana, mediana+1}
        \IF{es una posición válida}
            \STATE contar los cruces por ponerlo en esa posición
            \IF{lo inserté por primera vez o me genera menos cruces que la mejorPosicion}
                \STATE mejorPosicion $\leftarrow$ posicionActual
            \ENDIF
        \ENDIF
    \ENDFOR
    \STATE poner al nodo en mejorPosicion
\ENDWHILE
\end{algorithmic}
\end{algorithm} 








\section{Comparación de las heurísticas constructivas}

A fin de decidir cual o cuales de estas heurísticas se comporta mejor, y al
igual que con el algoritmo exacto, decidimos hacer primero una implementación en 
Python por las facilidades que da el lenguaje en cuanto a velocidad de desarrollo. 
Utilizando estas implementaciones, aplicamos las heurísticas a numerosos casos de prueba
y comparamos los resultados, teniendo en cuenta no solo la calidad de los resultados
obtenidos sino también el costo temporal.

A priori lo que esperamos es que la heurística de inserción de ejes de mejores 
resultados por el hecho de que reinserta nodos, lo cual le da varias oportunidades para 
fijar la posición de un nudo dado, por lo cual podría corregir errores cometidos por 
insertar cuando todavía había pocos nodos en el dibujo.

Sin embargo, es de esperarse que este método sea considerablemente más lento que los demás:
en primer lugar, porque itera tantas veces como ejes se agreguen, lo cual podría ser $O(n^2)$ 
siendo $n$ la cantidad de nodos, y en segundo lugar porque cada una de estas iteraciones 
requiere de $O(n^2)$ conteos de cruces. Si a esto le sumamos el costo de contar los 
cruces vemos que el costo de esta heurística es bastante elevado.

Respecto de la heurística de la mediana, resulta difícil prever como se comportará
el algoritmo. Si bien es de esperarse que tenga un costo temporal reducido (ya que solo
``prueba'' tres posiciones para cada nodo y por lo tanto realiza pocos conteos de cruces),
su performance no es fácil de predecir.

Finalmente, respecto a la inserción \textit{greedy} de los nodos, creemos que su costo 
será menor que el de la inserción de ejes, pero sus resultados podrían no ser tan buenos
en razón de su simpleza inherente.

Ejecutamos los siguientes tests:
\begin{enumerate}
\item Comparación de Heuristicas de inserción \textit{greedy} de nodos:
    Primero comparamos a las diferentes formas de elegir al nodo candidato, para 
    observar si alguna de las formas de hacerlo se desempeña mejor.

\item Comparación entre heurísticas:
    \begin{enumerate}
    \item $n$ nodos en cada partición, $n$ creciente, $\frac{n^2}{2}$ ejes, 60\% de nodos nuevos
    \item $n$ nodos en cada partición, $n$ creciente, $\frac{n^2}{2}$ ejes, 40\% de nodos nuevos
    \item $n$ nodos en cada partición, $n$ creciente, $3n$ ejes, 60\% de nodos nuevos
    \item $n$ nodos en cada partición, $n$ creciente, $3n$ ejes, 40\% de nodos nuevos
    \item $n = 30$, cantidad de ejes creciente, 40\% de nodos nuevos
    \end{enumerate}
\end{enumerate}

En cada uno de ellos se midió sobre grafos aleatorios de los tamaños mencionados la cantidad 
de cruces lograda y el tiempo empleado para lograr el dibujo.

Si bien los tiempos de ejecución en un lenguaje interpretado como Python, son por lo 
general bastante mayores que los tiempos de ejecución en C++, consideramos que son 
igualmente válidos como herramienta de comparación para observar una tendencia general 
en el comportamiento de las heurísticas. Por otro lado, dado que implementar en este 
lenguaje nos resulta mucho más sencillo, consideramos que vale la pena probar a tres 
heurísticas experimentalmente en lugar de proponer una única para implementar en C++.

\subsection{Criterios de selección de nodos para la heurística de inserción de nodos}
Las pruebas que realizamos consistieron en aplicar la heurística de inserción de nodos 
a grafos aleatorios variando la cantidad de nodos en cada partición.

En la primer experiencia utilizamos grafos con $m=2*n$ y un $40\%$ de nodos fijos (en 
adelante $n$ es la cantidad de nodos de cada partición). En la segunda experiencia, 
la cantidad de ejes fue $m=\frac{n^2}{2}$ y el porcentaje de nodos fijos fue también del $40\%$.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.6]{./graficos/comparacionInsercionNodos/exp2.png}}
\subfigure[]{
\includegraphics[scale=0.6]{./graficos/comparacionInsercionNodos/exp1.png}} 
\end{figure}

Observamos en estas experiencias que la cantidad de cruces encontrada por los 
tres métodos es relativamente similar. Sin embargo el criterio de mayor grado 
parecería comportarse ligeramente mejor que los otros dos. Para nosotros tiene 
sentido que esto sea así, ya que si se utiliza el nodo de mayor grado con respecto
a lo que ya está puesto, ese nodo tiene más información (mas adyacentes puestos) 
por lo que sería razonable que pueda ubicarse mejor. Está claro que podría fallar, 
sin embargo a partir de esta idea, más lo que se observa en las pruebas, decidimos 
utilizar al nodo de mayor grado para la heurística de inserción de nodos.

\subsection{Comparación de heurísticas constructivas}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cruces producidos en función de $n$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces1.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de $n$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos1.png} }
\caption{$n$ nodos en cada partición, $n$ creciente, $\frac{n^2}{2}$ ejes, 60\% de nodos nuevos}
\end{figure}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cruces producidos en función de $n$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces2.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de $n$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos2.png} }
\caption{$n$ nodos en cada partición, $n$ creciente, $\frac{n^2}{2}$ ejes, 40\% de nodos nuevos}
\end{figure}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cruces producidos en función de $n$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces3.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de $n$]{
\includegraphics[scale=0.69]{./graficos/comparacionConstructivas/tiempos3.png} }
\caption{$n$ nodos en cada partición, $n$ creciente, $3n$ ejes, 60\% de nodos nuevos}
\end{figure}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cruces producidos en función de $n$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces4.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de $n$]{
\includegraphics[scale=0.67]{./graficos/comparacionConstructivas/tiempos4.png} }
\caption{$n$ nodos en cada partición, $n$ creciente, $3n$ ejes, 40\% de nodos nuevos}
\end{figure}

\begin{figure}[H]
\centering
\subfigure[Cruces producidos en función de $m$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces5.png}}
\subfigure[Tiempo en segundos en función de $m$]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos5.png} }
\caption{ $n = 30$, $m$ creciente, 40\% de nodos nuevos}
\setcounter{subfigure}{0}
\end{figure}


\section{Análisis de los resultados}

Al observar los gráficos de las experiencias lo primero que salta a la vista es 
que el tiempo de ejecución de la heur'istica de inserción de ejes es mucho más 
grande que el de las demás. Esta situación, que se hace más notoria en grafos densos, 
hace que su uso no sea recomendable, más aún si tenemos en cuenta como muestran las demás
experiencias que los resultados que obtiene no son significativamente mejores que los de
las otras. En la experiencia 5 vemos como para un grafo con 30 nodos y 799 ejes la diferencia entre 
la inserción de nodos y la inserción de ejes de 442 cruces a favor de la insercióon de ejes 
(142131 contra 141689), lo cual es sólo un 0.3\%, pero los tiempos fueron de 0.5160 y 13.6870
segundos respectivamente, lo cual es aproximadamente 26 veces más. En función de esta
ineficiencia temporal, si bien los resultados que ofrece son buenos, decidimos descartar
la heurística de inserción de ejes.

Por otro lado, la heurística de la mediana se muestra como la más rápida, como habíamos
estimado previamente. Sin embargo en cuanto a la cantidad de cruces suele dar peores 
resultados que las otras dos. Es por esto, que decimos entonces descartar la heurística
de la mediana por obtener resultados de peor calidad sin un ahorro sustancial de tiempo
de ejecución.

Finalmente elegimos implementar en C++ la heurística de inserción de nodos, ya que 
consideramos que de las tres alternativas planteadas obtiene un buen compromiso entre
calidad de los resultados y tiempos cortos de ejecución. 

\section{Detalles de implementación}

La implementación al igual que en el caso del algoritmo exacto, utiliza diversos
contenedores de la STL. Si se observa el código en C++ hay algunas modificaciones
respecto del algoritmo presentado hasta el momento que responden a los cambios
realizados para agregar factores aleatorios a las soluciones propuestas por la 
heurística. Estas modificaciones son necesarias para la implementación de GRASP
y son detalladas en \ref{modificaciones_constructiva}. 

Como particularidad de implementación se puede mencionar el uso de \verb0std :: sort0
para ordenar la secuencia de nodos por insertar según su grado de adyacencias
(si solo se debe tomar el máximo esto es ineficiente, pero en el contexto del GRASP
donde deben tomarse los $k$ primeros elementos es lo más conveniente). Para este
fin se utiliza un objeto adaptador que es el responsable de las comparaciones
entre elementos según su grado.

%FIXME: unificar notacion
%FIXME: revisar si el orden esta bien, ademas si esta bien expresarlo asi. Por ej. se suprime un movil*log(movil) que tal vez este bueno dejar
\section{Cálculo de complejidad}
\label{complejidadDeLaConstructiva}
Antes de comenzar, realizamos una limpieza del grafo, para no considerar a los nodos que tienen
grado nulo. Como comentamos en el apartado \ref{sacoNulos}, esto tiene un costo $O(V_1+V_2+m)$ donde 
$V_i$ es la cantidad de nodos de partición $i$ sin filtrar y $m$ la cantidad de ejes. Este costo se 
deberá sumar a la complejidad total.

La heur'istica de inserci'on de nodos comienza asignando variables y atributos 'utiles para la reutilizaci'on 
de c'alculos. Inicializamos dos listas de nodos fijos y dos de nodos a agregar (un par para cada partici'on), 
y los diccionarios de adyacencias parcial, grado parcial, posiciones y nodos móviles. Todo esto tiene un costo 
de $O(v_{max} + m)$. Adem'as, en esta parte inicializamos la variable $cruces$, contando los cruces del 
dibujo original (fijo) sin agregar ning'un nodo, lo que nos cuesta $O(m*log(fijos_{max})+fijos_{max}))$.
Finalmente la parte de inicializaci'on nos cuesta $O(n + m + m*log(fijos_{max})+fijos_{max})$, con $m$ su 
cantidad de ejes, y $fijos_{max}$ la cantidad de nodos fijos de la partici'on que tiene m'as nodos fijos.

Veamos ahora cuanto nos cuesta elegir un nodo entre los nodos a agregar. Primero ordenamos de forma creciente
(con sort de STL) los nodos a agregar por su grado parcial (considerando solamente los ejes que van del nodo 
hacia un nodo fijo o del nodo hacia un nodo que ya fue agregado al dibujo en iteraciones previas).
Este ordenamiento tiene complejidad $O(cantMovilesPi*log(cantMovilesPi))$. Si bien para tomar el máximo
valor no es necesario ordenar, las extensiones futuras vinculadas con la aleatorización del algoritmo
si requieren de disponer de la secuencia ordenada. Por esta razón, consideramos este costo como una cota de peor
caso de todas las variantes del algoritmo. 

Luego de ordenarlos, tomamos el primero de la secuencia. Luego estos pasos tienen un costo 
$O(cantMovilesPi*log(cantMovilesPi))$, siendo $Pi$ la partici'on sobre la cual estamos agregando el nodo.
%iteramos la secuencia hasta que el grado maximo sea mayor al grado del nodo en la posición que estamos mirando y de estos nodos nos quedamos con uno, esto nos cuesta $O(cantMovilesPi)$. Luego estos pasos tienen un costo $O(cantMovilesPi + cantMovilesPi*log(cantMovilesPi))$, siendo Pi la partici'on sobre la cual estamos agregando el nodo.

Ahora buscamos una de las mejores posiciones en la partici'on para insertar este nodo. Primero 
actualizamos la lista de adyacencias parciales para incorporar las adyacencias del nodo que voy a agregar 
(esto es necesario pues las funciones de conteo de cruces se usan dentro del subgrafo fijo y por tanto para 
que tengan en cuenta al nodo a agregar, es necesario completarlas con sus ejes) y luego insertamos el nodo 
al final de la partici'on.

Actualizar la lista de adyacencias parcial tiene un costo $O(m_a)$, con $m_a$ los ejes del nodo a agregar. 
Sin embargo, una vez que se agregan todos los nodos, en el peor de los casos se agregan todos los ejes también, 
por lo que esto tiene un costo $O(m)$. Luego contamos los cruces por agregar atrás, lo cual tiene un costo 
$O(v_{max}+m)$. Ahora \textit{swapeamos} el nodo con su nodo anterior de la partición y recalculamos los 
cruces hasta que el nodo a agregar queda primero en la partición. Aqu'i podemos utilizar lo mostrado en 
el apartado que explica el conteo de cruces, y lo hacemos con costo $O(min(max(vi,m_a,m_b),m_a*m_b))$. Repetir
este proceso por cada posici'on en la partici'on que estamos agregando, tiene un costo de 
$O(cantModosParticion * min(max(vi,m_a,m_b),m_a*m_b))$. Además, $max(v_i, m_a, m_b) \leq v_{max}$, puesto que $m_a$ 
y $m_b$ son a lo sumo tan grandes como la partición mas grande (en el caso en el que los nodos estén relacionados con 
todos los de la partición de enfrente) y también vale $min(max(vi,m_a,m_b),m_a*m_b) \leq max(vi,m_a,m_b)$. De esto
resulta que la complejidad de este ciclo nos queda $O(v_{max}^2)$.

Finalmente, insertamos el nodo y actualizamos los grados parciales y el vector de posiciones, con un costo de $O(m + v_{max})$.

Dado que este procedimiento lo hacemos para todos los nodos a agregar, la complejidad resultante es: 

$$O(cantMoviles*(\underbrace{m + v_{max}}_{a} + \underbrace{v_{max}^2}_{b} + \underbrace{Moviles + MovilesP1*log(MovilesP1) + MovilesP2*log(MovilesP2))}_{c} + \underbrace{m*log(p_{max})+p_{max}}_{d})  (*)$$ 

\begin{itemize}
\item $a$ es por agregar al nodo atrás de la partición
\item $b$ es por moverlo por toda la partición mediante \textit{swaps}
\item $c$ es por obtener cada vez uno de grado máximo
\item $d$ es por obtener por primera vez los cruces
\end{itemize}

Pero $* \subseteq O(Moviles*v_{max}^2 + m*log(fijos_{max})+fijos_{max})$, siendo Moviles 
la cantidad total de nodos a agregar, $v_{max}$ la cantidad de nodos de la partici'on más 
grande del dibujo resultante, $m$ la cantidad de ejes del dibujo resultante y $p_{max}$ la 
cantidad de nodos fijos de la partici'on que m'as nodos fijos tiene.

Esto es así porque:

$O(m+v_{max}) \subseteq O(Moviles*v_{max}^2)$ dado que $m \leq v_{max}*v_{max}$ 

$O(MovilesPi + MovilesPi*log(MovilesPi)) \subseteq O(MovilesPi*log(MovilesPi))$, y como 
$MovilesPi*log(MovilesPi) \leq v_{max}*log(v_{max}) \leq v_{max}*v_{max}$, vale 
que $O(MovilesPi + MovilesPi*log(MovilesPi)) \subseteq  O(v_{max}^2)$

Finalmente, a esta complejidad obtenida debemos agregarle el costo de la ``limpieza'' del 
grafo. Por lo tanto, la complejidad total es:
$$O(Moviles*v_{max}^2 + m*log(fijos_{max})+fijos_{max}+ V_{1}+V_2+m)$$

El tamaño de la entrada $t$, lo podemos definir de la siguiente manera:

$$ t = log(P_1)+ \sum_{i=1}^{P_1}{log((p_1)_i)}+ log(P_2)+ \sum_{i=1}^{P_2}{log((p_2)_i)} + log(m_p) + \sum_{i=1}^{m_p}{log((e_i)_0) + log((e_i)_1)} $$
 $$+log(IV_1) + \sum_{i=1}^{IV_1}{log((iv_1)_i)} + log(IV_2) + \sum_{i=1}^{IV_2}{log((iv_2)_i)} + log(m_{iv})+ \sum_{i=1}^{m_{iv}}{log((e'_i)_0) + log((e'_i)_1)} $$ 

donde $P_i$ es la cantidad de nodos originales de la primera partición, $m_p$ es la cantidad 
de ejes originales, $IV_i$ es la cantidad de nodos que se agregan a la partición $i$ y $m_iv$ es 
la cantidad de ejes que se agregan.

Luego vale que:
$$t \geq log(P_1)+ v_1+ log(P_2)+V_2 + log(m_p) +m +log(IV_1) + log(IV_2) + log(m_{iv})$$
 
A partir de esto, vemos que:
$$ t \geq V_i \geq v_i$$
$$ t \geq V_{max} \geq v_{max}$$
$$ t \geq Moviles$$
$$ t \geq fijos_{max}$$
$$ t \geq m $$

Y por lo tanto resulta que el orden de toda la heurística es:
$$O(Moviles*v_{max}^2 + m*log(fijos_{max})+fijos_{max}+ V_{1}+V_2+m) \subseteq O(t^3 + t*log(t)+t) \subseteq O(t^3)$$ 

\section{Análisis de la heurística}
\subsection{Casos patológicos}
\label{mal-caso} 

Para ver qué tan malo podría ser el comportamiento de nuestra heurística, 
intentamos buscar casos donde el resultado que proponga el algoritmo diste 
arbitrariamente de la solución óptima.

Un caso donde la heurística se equivoca es el siguiente:

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.25]{./figuras/constructivas/malCasoConstructivo.png}
\caption{Caso patológico para la heurística constructiva}
\end{figure}

En este ejemplo los nodos numerados son los nodos que se agregan, mientras que 
los que tienen letras son los del dibujo original.

Veamos qué hace la heurística constructiva frente a este caso:
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Partimos del dibujo original]{
\includegraphics[scale=0.2]{./figuras/constructivas/malCons0.png}}\hspace{0.1in}
\subfigure[El 1 tiene mayor grado hacia lo que ya está. Como sirve cualquier posición, lo insertamos en la primera que probamos (recordar que vamos desde atrás hacia adelante)]{
\includegraphics[scale=0.2]{./figuras/constructivas/malCons1.png} }\hspace{0.1in}
\subfigure[La mejor posición para el nodo 2 es arriba de todo ya que no genera cruces]{
\includegraphics[scale=0.2]{./figuras/constructivas/malCons2.png}}\hspace{0.1in}
\subfigure[El nodo 3 está obligado a colocarse en una posición que genera un cruce]{
\includegraphics[scale=0.2]{./figuras/constructivas/malCons3.png}}\hspace{0.1in}
\subfigure[Ocurre lo mismo para el nodo 4]{
\includegraphics[scale=0.2]{./figuras/constructivas/malCons4.png}}
\end{figure}

Como vemos, en este caso, frente a un grafo para el cual existe un dibujo sin ningún
cruce, nuestra heurística obtiene un dibujo con 2 cruces. Ahora bien, si tuviéramos 
un nodo nuevo más que estuviera relacionado con $D$, el dibujo óptimo seguiría teniendo 0 cruces, 
y sin embargo nuestra heurística daría 3 cruces. Esto puede generalizarse: en general si a 
este grafo le agregamos nodos fijos debajo de $D$ y nodos nuevos unidos a éstos (con grado 1),
el número de cruces óptimo sigue siendo 0, pero nuestra heurística va a proponer un dibujo con
una cruz más por cada par de nodos que se agregue.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.25]{./figuras/constructivas/familiaMala.png}
\caption{Familia de casos patológicos}
\end{figure}

Luego, la cantidad de cruces del dibujo propuesto por la heurística constructiva es $k$, 
donde $k$ es la cantidad de pares de nodos de la forma nodo viejo - nodo nuevo que se agregan
al dibujo original.

Veamos gráficamente la cantidad de cruces que encuentra la heurística en función de la cantidad de nodos:
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.5]{./graficos/casoBorde/crucesCasoBordeConstructiva.png}
\caption{Cantidad de cruces al aplicar la heurística a grafos de la familia presentada}
\end{figure}

\subsection{Comparación con la heurística trivial}

La heurística que elegimos se comporta bien en cuanto a tiempo y cruces 
si la comparamos con las otras heurísticas planteadas. A modo de referencia 
nos pareció interesante comparar su comportamiento con el de la heurística 
optimista, consistente en devolver el dibujo agregando los nodos nuevos al
al final dl dibujo en el orden en que fueron recibidos, asumiendo que se
trata de la solución óptima.

Esta experiencia nos permitirá ver si por lo menos vale la pena el tiempo gastado en construir la solución.
A continuación se muestran los resultados:

%TODO: son demasiado lindos, algo no cierra en los ejemplos
\begin{figure}[H]
\centering
\subfigure[]{
\includegraphics[scale=0.5]{./graficos/constructivaVSTrivial/ConstructivaVSTrivial1.png}}
\subfigure[]{
\includegraphics[scale=0.5]{./graficos/constructivaVSTrivial/ConstructivaVSTrivial2.png} }
\end{figure}
\begin{figure}[H]
\centering
\subfigure[]{
\includegraphics[scale=0.6]{./graficos/constructivaVSTrivial/ConstructivaVSTrivial2.png} }
\caption{Comparación entre inserción \textit{greedy} de nodos y heurística optimista}
\setcounter{subfigure}{0}
\end{figure}

Como vemos, nuestra heurística se muestra considerablemente mejor que el 
acercamiento optimista, y esta mejora se hace más clara en grafos densos y 
con un número alto de nodos.

\subsection{Tiempo de ejecución}

Para observar el comportamiento decidimos medir los tiempos variando distintos 
parámetros en los grafos que utilizamos como entrada para la heurística, con la idea de
ver qué influencia tienen en el tiempo de ejecución del algoritmo las variaciones de 
la cantidad de nodos, ejes y nodos nuevos.

Nuestra primera experiencia consistió en utilizar grafos aleatorios con $n$ 
nodos en cada partición. Variamos este $n$ con distintos porcentajes de nodos móviles y ejes. 
Los resultados son los siguientes:

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.65]{./graficos/benchmarkConstructiva/100NodosAumentandoNodosComplejidad.png}
\caption{Tiempo en función de la cantidad de nodos en cada partición}
\end{figure}

Los porcentajes indican la proporción de ejes con respecto al grafo bipartito completo
correspondiente, y la cantidad de nodos móviles respecto del total de los nodos de cada
partición.

Lo primero que observamos es que la complejidad teórica aproxima muy bien los resultados 
empíricos. Por otro lado, se puede notar también a simple vista que no solo la cantidad 
de nodos tiene una fuerte influencia en el tiempo de ejecución, sino que también la tiene
alguno de los dos parámetros estudiados. Esto es de esperarse como se vio en el análisis de complejidad
de la heurística (sección \ref{complejidadDeLaConstructiva}). Esto tiene sentido, ya que más
ejes hacen más costoso el cálculo de cruces, y más nodos móviles aumentan el número de pasos 
hasta construir una solución. A continuación estudiamos por separado los dos parámetros.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.5]{./graficos/benchmarkConstructiva/100NodosAumentandoMoviles.png}
\caption{Tiempo en función de la cantidad de nodos móviles en cada partición}
\end{figure}

Los porcentajes indican la proporción de ejes en el grafo con respecto al completo.

Como vemos, hay una influencia muy grande de la cantidad de nodos móviles. A medida 
que aumenta la cantidad de nodos móviles, aumenta el tiempo, pero observamos que a 
partir de un 50\% de nodos móviles, el crecimiento parece desacelerarse paulatinamente.
Esto concuerda con el hecho de que cada decisión de inserción de un nuevo nodo se basa
en una cantidad de chequeos de cruces en tantas ubicaciones como existan en el dibujo.
Como una ubicación está determinada por los espacios entre nodos ya fijados, si el dibujo
original es más chico, se deberán hacer menos intentos para colocar el primer nodo móvil
que si hubiera más nodos ya fijados.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.5]{./graficos/benchmarkConstructiva/100NodosAumentandoEjes.png}
\caption{Tiempo en función de la cantidad de ejes en cada partición}
\end{figure}

En este caso, los porcentajes hacen referencia a la cantidad de nodos libres.

Lo que observamos es que una mayor cantidad de ejes conduce a un mayor tiempo 
de ejecución. El tiempo de ejecución tiene un aspecto lineal, lo cual se condice 
con el análisis teórico, ya que la complejidad quedaba como una función lineal de $m$. 

A modo de conclusión, podemos decir que los tiempos de ejecución obtenidos 
empíricamente reflejaron a los obtenidos en el análisis teórico de la heurística.
